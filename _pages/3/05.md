---
title: Imprimindo Texto
author: attilathedud
date: 2023-12-25
category: Programação
layout: post
---

# Alvo

Nosso alvo nesta aula é o **Wesnoth 1.14.9**.

# Identificar

Vamos **imprimir nosso próprio texto** dentro do Wesnoth usando uma code cave. Para isso, localizaremos a função responsável por exibir texto e modificaremos o conteúdo que ela imprime.

# Entender

Existem três formas de exibir texto personalizado num jogo:

1. **Overlay externo** — janela separada sobreposta ao jogo (ex: como o sistema de overlay da Steam)
2. **Code cave no loop de renderização** — chama a função de texto em cada frame
3. **Code cave na função de texto** — intercepta a função que imprime texto e muda o que será exibido

Para o Wesnoth, usaremos a **terceira abordagem** — a mais simples para este jogo. Nas próximas aulas, veremos as outras também.

# Localizando o Texto

Primeiro, precisamos encontrar onde o texto fica armazenado na memória. Usaremos o texto da *Terrain Description* quando clicamos no tile *Ford* (Vau).

Selecione um mapa que tenha tiles *Ford*, como *Den of Onis*:

![Mapa com Tiles Ford](/assets/images/3/5/wesnoth1.png)

Clique num tile *Ford* e selecione *Terrain Description*:

![Terrain Description num tile Ford](/assets/images/3/5/wesnoth2.png)

A descrição aparece com um longo texto:

![Terrain Description num tile Ford](/assets/images/3/5/wesnoth3.png)

Feche a caixa de descrição e use o Cheat Engine para buscar algumas palavras únicas do texto. Por ser um texto longo e único, poucos resultados aparecem:

![Buscando Texto no Cheat Engine](/assets/images/3/5/wesnoth4.png)

Para determinar qual resultado é o correto, mude a primeira letra de cada string encontrada e veja qual mudança aparece no jogo. No exemplo, a string começando com *Lhen* é a correta — seu endereço é `0x10CE996B`:

![Determinando o Endereço da String no Cheat Engine](/assets/images/3/5/wesnoth5.png)

# Localizando a Função de Impressão

Agora que sabemos onde o texto está, precisamos encontrar quem o lê para exibi-lo. Sete um breakpoint de leitura num byte do texto no x64dbg:

![Breakpoint no Byte de Texto](/assets/images/3/5/wesnoth6.png)

Invoque o *Terrain Description* novamente — o breakpoint vai popar imediatamente:

![Breakpoint no Byte de Texto](/assets/images/3/5/wesnoth7.png)

Estamos numa função que copia os bytes do texto para um buffer. Use *Execute till return* e *Step Over* para subir na hierarquia e chegar à função que chama este código:

![Breakpoint no Byte de Texto](/assets/images/3/5/wesnoth8.png)

Esse `call` em `0x005ED114` provavelmente é responsável por preencher a caixa de terrain description com texto. Sete um breakpoint nele e invoque o *Terrain Description* de novo:

![Breakpoint no Byte de Texto](/assets/images/3/5/wesnoth9.png)

O texto é carregado no registrador **edx**. O código em `0x005ED11A` empurra **edx** para a pilha — passando o texto como parâmetro para a função.

# Endianness na Memória

Na seção anterior, você pode ter notado que o endereço em **edx** não combina exatamente com o endereço que encontramos no Cheat Engine. Isso é **endianness**.

CPUs Windows são **little endian**: o byte menos significativo é armazenado no menor endereço. Na prática, endereços ficam "invertidos" na memória.

Por exemplo: o endereço `0x12345678` na memória aparece como `0x78 0x56 0x34 0x12`.

Para ver o texto correto a partir do valor em **edx**, selecione os bytes no dump e use *Follow in Dump* — o x64dbg vai navegar para o endereço real:

![Ação Follow in Dump](/assets/images/3/5/wesnoth10.png)
![Seção Dump](/assets/images/3/5/wesnoth11.png)
![Seção Dump com String](/assets/images/3/5/wesnoth13.png)

Em assembly, acessamos o endereço apontado por **edx** assim:

```c++
mov eax, dword ptr ds:[edx]    ; carrega o endereço do texto de edx para eax
```

# Modificando o Texto

Vamos criar uma code cave no `call` em `0x005ED129` — que é 5 bytes, exatamente o tamanho de um `jmp`. Coloque a cave em `0x01343E1B` e redirecione:

![Redirecionamento](/assets/images/3/5/wesnoth14.png)

A cave vai:
1. Salvar registradores (`pushad`)
2. Carregar o endereço do texto de **edx** em **eax**
3. Usar `inc` para aumentar o valor do primeiro caractere (ex: 'A' → 'B')
4. Restaurar registradores (`popad`)
5. Reexecutar o `call` original
6. Retornar ao código do jogo

![Redirecionamento](/assets/images/3/5/wesnoth15.png)

Volte ao Wesnoth e clique em *Terrain Description* várias vezes. Você notará que um caractere muda a cada clique — confirmando que o hack funciona:

![Texto Alterado](/assets/images/3/5/wesnoth16.png)

> **Próximos passos:** Em aulas futuras usaremos overlays modernos (como ImGui) para exibir texto customizado de forma mais elegante, sem precisar interceptar as funções de texto do jogo. Isso é especialmente relevante para jogos mais modernos que usam Unreal Engine ou Unity.

&nbsp;