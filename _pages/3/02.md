---
title: External Memory Hack
author: attilathedud
date: 2023-12-25
category: Programação
layout: post
---

# Alvo

Nosso alvo nesta aula é o **Wesnoth 1.14.9**.

# Identificar

Vamos criar um **programa C++ externo** que modifica o ouro do jogador no Wesnoth. "Externo" significa que é um `.exe` separado — você roda ele, e ele manipula a memória do Wesnoth de fora.

# Entender

Na aula [Derrotando a DMA](/pages/2/09/), encontramos o ponteiro base do jogador em `0x017EECB8` e os offsets para chegar ao ouro: `[[0x017EED18] + 0xA90] + 4`.

Como esses endereços são estáticos, podemos codificá-los num programa e re-executá-lo sempre que quisermos mudar o ouro — sem precisar repetir o processo manual no Cheat Engine.

# Visual Studio

Para compilar C++, precisamos de um **compilador** (transforma código em opcodes) e um **linker** (transforma opcodes em `.exe`). Essas ferramentas geralmente vêm juntas num **IDE** (Ambiente de Desenvolvimento Integrado).

Usaremos o **Visual Studio** — o IDE padrão para desenvolvimento Windows da Microsoft. A edição Community é gratuita e pode ser instalada via Chocolatey:

```powershell
choco install visualstudio2022community
```

> **Atualização 2026:** O original do curso menciona Visual Studio 2019. Em 2026, use o **Visual Studio 2022** — tem melhor suporte a C++20, ferramentas de diagnóstico aprimoradas e é a versão ativa com suporte.

No Visual Studio, o código é organizado em **projetos**, e projetos em **soluções**. Por exemplo:

```
Wesnoth - Solução
    Engine - Projeto
        Player.cpp - Código fonte
        main.cpp   - Código fonte
    UI - Projeto
    Network - Projeto
```

Para criar projetos C++, instale o componente *Desktop development with C++* na tela de setup do Visual Studio.

![Pacote C++ Desktop Development](/assets/images/3/2/ide1.png)

# Criando o Projeto

Crie um projeto C++ vazio e nomeie *ExternalMemoryHack*:

![Projeto C++ Vazio](/assets/images/3/2/ide2.png)

Clique com botão direito em *Source Files* → *Add → New Item*. Adicione um arquivo *main.cpp*:

![Visual Studio Adicionar Arquivo](/assets/images/3/2/ide3.png)
![Visual Studio Adicionar Arquivo C++](/assets/images/3/2/ide4.png)

# Conceitos Básicos de C++

Dois conceitos essenciais para esta aula:

1. Programas C++ começam na função **`main`**, que precisa retornar um inteiro
2. Podemos chamar funções da **API do Windows** para ler/escrever a memória de outros processos

```c++
int main(int argc, char** argv) {
    // nosso código aqui
    return 0;
}
```

Para usar APIs do Windows, incluímos o header `Windows.h`:

```c++
#include <Windows.h>
```

# Lendo Valores da Memória

A API para ler a memória de outro processo é `ReadProcessMemory`. Sua definição:

```c++
BOOL ReadProcessMemory(
    HANDLE  hProcess,       // handle do processo alvo
    LPCVOID lpBaseAddress,  // endereço a ler
    LPVOID  lpBuffer,       // buffer onde o valor vai ser guardado
    SIZE_T  nSize,          // quantos bytes ler
    SIZE_T  *lpNumberOfBytesRead  // quantos bytes foram de fato lidos
);
```

Construindo a chamada passo a passo, para valores que ainda não temos vamos usar variáveis:

```c++
ReadProcessMemory(wesnoth_process, 0x017EECB8, &gold_value, 4, &bytes_read);
```

Precisamos declarar as variáveis do buffer e do número de bytes lidos. Como leremos 4 bytes (o tamanho de um inteiro), usamos `DWORD` (32 bits = 4 bytes):

```c++
DWORD gold_value = 0;
DWORD bytes_read = 0;
ReadProcessMemory(wesnoth_process, (void*)0x017EECB8, &gold_value, 4, &bytes_read);
```

# Abrindo um Processo

Para obter o `hProcess`, usamos `OpenProcess`:

```c++
HANDLE OpenProcess(
    DWORD dwDesiredAccess,   // nível de acesso desejado
    BOOL  bInheritHandle,    // herdar handle? (não precisamos)
    DWORD dwProcessId        // ID do processo
);
```

```c++
HANDLE wesnoth_process = OpenProcess(PROCESS_ALL_ACCESS, true, process_id);
```

Para o `process_id`, usamos `GetWindowThreadProcessId` que dado um handle de janela retorna o PID:

```c++
DWORD process_id = 0;
GetWindowThreadProcessId(wesnoth_window, &process_id);
```

E para o handle da janela, `FindWindow` busca pelo título:

```c++
HWND wesnoth_window = FindWindow(NULL, L"The Battle for Wesnoth - 1.14.9");
```

Juntando tudo, nosso código fica:

```c++
#include <Windows.h>

int main(int argc, char** argv) {
    HWND wesnoth_window = FindWindow(NULL, L"The Battle for Wesnoth - 1.14.9");

    DWORD process_id = 0;
    GetWindowThreadProcessId(wesnoth_window, &process_id);

    HANDLE wesnoth_process = OpenProcess(PROCESS_ALL_ACCESS, true, process_id);

    DWORD gold_value = 0;
    DWORD bytes_read = 0;
    ReadProcessMemory(wesnoth_process, (void*)0x017EECB8, &gold_value, 4, &bytes_read);

    return 0;
}
```

Compile o projeto com *Build → Build Solution*:

![Menu Build](/assets/images/3/2/ide6.png)

Se houver erros de tipo (casting), o Visual Studio vai listá-los na aba *Error List* — normalmente basta adicionar `(void*)` ou `L` antes de strings para resolver:

![Erros do Projeto](/assets/images/3/2/ide5.png)

# Depurando Nosso Programa

Para verificar que estamos lendo a memória corretamente, use o **debugger do Visual Studio**. Adicione um breakpoint na linha do `ReadProcessMemory` clicando na margem esquerda. Depois clique em **Local Windows Debugger**:

![Debugger do Visual Studio](/assets/images/3/2/ide8.png)

Quando o breakpoint parar, você pode ver os valores das variáveis na parte inferior. Compare `gold_value` com o que o Cheat Engine mostra para ter certeza:

![Debugger do Visual Studio](/assets/images/3/2/ide9.png)

# Seguindo a Cadeia de Ponteiros (DMA)

Agora que conseguimos ler do endereço base, precisamos seguir os offsets até o ouro: `[[0x017EED18] + 0xA90] + 4`.

```c++
DWORD gold_value = 0;
DWORD bytes_read = 0;

// Lê o valor em 0x017EED18
ReadProcessMemory(wesnoth_process, (void*)0x017EED18, &gold_value, 4, &bytes_read);

// Adiciona o offset 0xA90 e lê o próximo nível
gold_value += 0xA90;
ReadProcessMemory(wesnoth_process, (void*)gold_value, &gold_value, 4, &bytes_read);

// Offset final de 4 → chegamos ao endereço do ouro
gold_value += 4;
```

Use um breakpoint no segundo `ReadProcessMemory` para comparar o resultado com o Cheat Engine:

![ReadProcessMemory e Cheat Engine](/assets/images/3/2/ide10.png)

# Escrevendo na Memória

A API para escrever é `WriteProcessMemory` — funciona de forma muito similar ao `ReadProcessMemory`:

```c++
BOOL WriteProcessMemory(
    HANDLE  hProcess,
    LPVOID  lpBaseAddress,
    LPCVOID lpBuffer,         // valor a escrever
    SIZE_T  nSize,
    SIZE_T  *lpNumberOfBytesWritten
);
```

Declaramos o novo valor e chamamos:

```c++
DWORD new_gold_value = 555;
DWORD bytes_written = 0;
WriteProcessMemory(wesnoth_process, (void*)gold_value, &new_gold_value, 4, &bytes_written);
```

Quando executado, o ouro do jogador muda para 555. O hack agora pode ser distribuído como um `.exe` — qualquer pessoa pode rodar e ter o ouro modificado:

![WriteProcessMemory](/assets/images/3/2/ide11.png)

O código completo está disponível no [GitHub](https://github.com/GameHackingAcademy/Wesnoth_ExternalGoldHack) para comparação.

&nbsp;
