---
title: Code Caves e DLLs
author: attilathedud
date: 2023-12-25
category: Programação
layout: post
---

# Alvo

Nosso alvo nesta aula é o **Wesnoth 1.14.9**.

# Identificar

Vamos criar uma **DLL com uma code cave** que, ao selecionar *Terrain Description*, muda o ouro do jogador para **888** antes de exibir a descrição.

# Entender

Na aula [Usando Code Caves](/pages/2/07/), criamos a cave diretamente no x64dbg — inserindo as instruções manualmente. O problema: essas mudanças são temporárias e se perdem quando o jogo fecha.

A solução é codificar a cave em C++ dentro de uma DLL. A DLL, ao ser injetada, modifica o código do jogo automaticamente. Assim, o hack persiste enquanto a DLL estiver carregada.

# Assembly em C++

C++ permite inserir código assembly diretamente usando a palavra-chave `__asm`:

```c++
__asm {
    pushad
}
```

Você também pode misturar C++ e assembly:

```c++
__asm { pushad }
int x = 0;
x = x + 1;
__asm { popad }
```

Variáveis declaradas no C++ podem ser referenciadas dentro dos blocos `__asm`.

# Funções como Code Caves

Para que o Wesnoth possa saltar para nossa cave, precisamos saber o **endereço** dela. A forma mais prática em C++: declarar a cave como uma **função** e usar `&` para obter seu endereço.

Mas existe um problema: quando o compilador gera uma função C++ padrão, ele adiciona automaticamente um **stack frame** (prólogo e epílogo):

```c++
codecave:
    push ebp
    mov ebp, esp
    ...
    mov esp, ebp
    pop ebp
    ret
```

Esse stack frame pode corromper o estado do jogo quando saltamos para a cave de fora. Para evitar isso, usamos `__declspec(naked)` — que instrui o compilador a *não* gerar o stack frame:

```c++
__declspec(naked) void codecave() {
    // apenas nosso assembly aqui
}
```

# Esqueleto da Cave

Crie um novo projeto DLL chamado *CodeCaveDLL* no Visual Studio. Adicione a estrutura do esqueleto:

```c++
#include <Windows.h>

DWORD ret_address = 0xCCAF90;    // endereço de retorno após a cave

__declspec(naked) void codecave() {
    __asm {
        pushad
    }

    // código C++ para modificar o ouro vai aqui

    __asm {
        popad
        mov eax, dword ptr ds:[ecx]     // instrução original (linha 1 que sobrescrevemos)
        lea esi, dword ptr ds:[esi]     // instrução original (linha 2 que sobrescrevemos)
        jmp ret_address                 // volta ao fluxo original do jogo
    }
}
```

> **Por que `ret_address` como variável?** O compilador C++ não consegue calcular o tipo correto de `jmp` para um endereço estático literal. Usar uma variável DWORD resolve essa ambiguidade.

# Modificando o Ouro

Entre os blocos `__asm`, adicionamos o código C++ para mudar o ouro. Como a função `naked` não tem stack frame próprio, **todas as variáveis devem ser globais**:

```c++
DWORD* player_base;
DWORD* game_base;
DWORD* gold;

__declspec(naked) void codecave() {
    __asm { pushad }

    player_base = (DWORD*)0x017EED18;
    game_base = (DWORD*)(*player_base + 0xA90);
    gold = (DWORD*)(*game_base + 4);
    *gold = 888;

    __asm {
        popad
        mov eax, dword ptr ds:[ecx]
        lea esi, dword ptr ds:[esi]
        jmp ret_address
    }
}
```

# Redirecionamento

Agora precisamos modificar o código do Wesnoth para saltar para nossa cave. O local de hook é o mesmo da aula anterior: `0x00CCAF8A`.

Mas código em memória tem **proteção de escrita**. Primeiro precisamos remover essa proteção com `VirtualProtect`. Depois, escrevemos os bytes do `jmp`:

A instrução `jmp` tem opcode `0xE9` seguido de 4 bytes que representam o deslocamento relativo até o destino. A fórmula:

```
deslocamento = endereço_destino - (endereço_jmp + 5)
```

Implementação em `DllMain`:

```c++
BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved ) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DWORD old_protect;
        unsigned char* hook_location = (unsigned char*)0x00CCAF8A;

        // Remove a proteção de escrita nos 6 bytes do hook
        VirtualProtect((void*)hook_location, 6, PAGE_EXECUTE_READWRITE, &old_protect);

        // Escreve o opcode 0xE9 (jmp)
        *hook_location = 0xE9;

        // Escreve os 4 bytes do deslocamento (endereço relativo)
        *(DWORD*)(hook_location + 1) = (DWORD)&codecave - ((DWORD)hook_location + 5);

        // O 6º byte vira NOP (instrução vazia) para não deixar lixo
        *(hook_location + 5) = 0x90;
    }

    return true;
}
```

# Testando

Compile, injete com AppInit_DLLs e inicie o Wesnoth. Selecione qualquer tile e clique em *Terrain Description*. O ouro vai mudar para **888** antes de exibir a descrição de terreno.

O código completo está no [GitHub](https://github.com/GameHackingAcademy/Wesnoth_CodeCaveDLL/).

&nbsp;