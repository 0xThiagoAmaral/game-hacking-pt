---
title: DLL Memory Hack
author: attilathedud
date: 2023-12-25
category: Programação
layout: post
---

# Alvo

Nosso alvo nesta aula é o **Wesnoth 1.14.9**.

# Identificar

Vamos criar uma **DLL** que modifica o ouro do jogador no Wesnoth sempre que ele pressionar a tecla **M**.

# Entender

Na aula anterior, usamos `ReadProcessMemory` e `WriteProcessMemory` para modificar a memória de fora do processo. Esse método funciona bem para valores simples, mas tem limitações:

- Difícil de trabalhar com estruturas complexas e classes
- Impossível "ouvir" eventos do jogo (como teclas pressionadas) de forma natural
- Criar code caves exigiria converter o código em opcodes manualmente

A solução: **injetar uma DLL dentro do processo do jogo**. Uma vez injetada, a DLL roda *dentro* do Wesnoth e pode:
- Acessar qualquer endereço de memória via ponteiros diretamente
- Criar threads que rodam em paralelo ao jogo
- Ler teclas e eventos do jogo

> **Metáfora:** Um executável externo é como um ladrão tentando entrar numa casa pela janela. Uma DLL injetada é como o ladrão *já estar dentro da casa, disfarçado de morador*.

# Criando uma DLL

No Visual Studio, crie um novo projeto vazio chamado *InternalMemoryHack*. Adicione um `main.cpp`. Depois, precisamos mudar o tipo de saída de `.exe` para `.dll`:

Clique com botão direito no projeto → *Properties*:

![Menu de Propriedades do Projeto](/assets/images/3/3/ide1.png)

Em *Configuration Properties → General*, mude *Configuration Type* de *Application (.exe)* para *Dynamic Library (.dll)*. Clique *Apply* e *OK*:

![Configuração do Projeto para DLL](/assets/images/3/3/ide2.png)

# Diferenças entre DLL e Executável

DLLs não podem ser executadas diretamente — elas precisam ser **carregadas dentro de outro processo**. Três diferenças importantes:

1. **`DllMain`** em vez de `main` — é a função chamada quando a DLL é carregada/descarregada
2. **`DllMain`** recebe o motivo pelo qual foi chamada (`fdwReason`)
3. **Variáveis declaradas na DLL existem na memória do processo pai** — ou seja, dentro do Wesnoth

A definição do `DllMain`:

```c++
BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,    // handle da DLL
    _In_ DWORD     fdwReason,   // motivo: carregada, descarregada, etc.
    _In_ LPVOID    lpvReserved
);
```

Quando `fdwReason == DLL_PROCESS_ATTACH (= 1)`, a DLL acabou de ser carregada.

# Verificando a Injeção com MessageBox

Antes de adicionar a lógica do hack, vamos verificar que a injeção funciona. Usamos `MessageBox` para exibir uma janela óbvia quando a DLL carrega:

```c++
#include <Windows.h>

BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved ) {
    MessageBox(0, 0, 0, 0);    // mostra uma janela de diálogo vazia
    return true;
}
```

Compile com *Build Solution*. O `.dll` vai aparecer em:
`C:\Users\IEUser\source\repos\InternalMemoryHack\Debug\InternalMemoryHack.dll`

# Injetando a DLL

Para injetar a DLL no Wesnoth, usaremos o **AppInit_DLLs** — uma chave do registro do Windows que carrega DLLs automaticamente em todo processo iniciado.

> **Nota:** Esse método funciona no **Windows 10** com Secure Boot desabilitado (o VirtualBox desabilita por padrão). Para Windows 11, use um **DLL Injector** (abordado em lição futura).

Verifique se o Secure Boot está desativado via **System Information**:

![Estado do Secure Boot](/assets/images/3/3/inject1.png)

Abra o **regedit** e navegue até:
`Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Windows`

![Caminho AppInit_DLL](/assets/images/3/3/inject2.png)

Dê duplo-clique em *AppInit_DLLs* e coloque o caminho completo da sua DLL:

![Caminho de Injeção AppInit_DLL](/assets/images/3/3/inject3.png)

Mude o valor de *LoadAppInit_DLLs* para **1** (ativo) ou **0** (inativo):

![Valor LoadAppInit_DLL](/assets/images/3/3/inject4.png)

A chave de registro deve ficar assim:

![Entrada AppInit_DLL no Registro](/assets/images/3/3/inject5.png)

Inicie o Wesnoth — várias MessageBoxes devem aparecer, confirmando que a DLL foi injetada com sucesso:

![DLL Injetada Exibindo MessageBox](/assets/images/3/3/inject6.png)

> ⚠️ **Importante:** O AppInit_DLLs injeta em **todos** os processos. Lembre-se de setar `LoadAppInit_DLLs = 0` **antes** de compilar a DLL, e reativar para **1** após compilar.

# Criando uma Thread

Agora vamos estruturar nosso hack. Queremos que ele fique ativo enquanto o Wesnoth está aberto e detecte quando o jogador pressionar **M**.

Modifique o `DllMain` para criar uma thread apenas quando a DLL é carregada pela primeira vez:

```c++
void injected_thread() {
    while (true) {
        Sleep(1);    // pausa 1ms para não sobrecarregar o processador
    }
}

BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved ) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)injected_thread, NULL, 0, NULL);
    }
    return true;
}
```

O `while (true)` mantém a thread rodando até o jogo fechar. O `Sleep(1)` evita que a thread use 100% do CPU.

# Detectando Teclas

A API `GetAsyncKeyState` verifica se uma tecla está pressionada e retorna `true` se sim:

```c++
while (true) {
    if (GetAsyncKeyState('M')) {
        // modifica o ouro aqui
    }
    Sleep(1);
}
```

# Usando Ponteiros para Modificar o Ouro

Como a DLL está *dentro* do Wesnoth, podemos usar ponteiros diretamente — sem precisar de `ReadProcessMemory` ou `WriteProcessMemory`:

```c++
// Nível 1: lê o valor no endereço base
DWORD* player_base = (DWORD*)0x017EED18;

// Nível 2: adiciona offset 0xA90 e lê o próximo nível
DWORD* game_base = (DWORD*)(*player_base + 0xA90);

// Nível 3: adiciona offset 4 e modifica o ouro
DWORD* gold = (DWORD*)(*game_base + 4);
*gold = 999;
```

Compile, restaure `LoadAppInit_DLLs = 1`, inicie o Wesnoth, entre num jogo e pressione **M**. O ouro vai mudar para 999:

![Hack DLL Injetado Alterando Ouro](/assets/images/3/3/inject7.png)

O código completo está no [GitHub](https://github.com/GameHackingAcademy/Wesnoth_InternalGoldHack/).

&nbsp;
