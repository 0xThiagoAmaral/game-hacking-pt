---
title: Code Caves
author: attilathedud
date: 2023-12-25
category: Debugging e Reversão
layout: post
---

# Contexto

Nas duas aulas anteriores, fizemos mudanças no código do jogo substituindo instruções. Mas e se quisermos:
- **Manter** a instrução original **e** adicionar código novo?
- **Substituir** uma instrução por **várias** ao mesmo tempo?

Simples substituição por NOP não resolve esses casos. É aí que entram as **code caves** (cavernas de código).

# O Que é uma Code Cave?

Uma **code cave** é uma seção de memória do jogo que você preenche com suas próprias instruções. O fluxo funciona assim:

1. Você **redireciona** o código original para `pular` para a sua cave
2. Dentro da cave, você **executa o que quiser** (nova funcionalidade)
3. No final da cave, você **recupera** a instrução original e **volta** ao fluxo normal do jogo

O nome vem da analogia: você está criando uma "caverna escondida" de instruções que o jogo executa sem saber. Na prática, a cave fica em seções de memória **não utilizadas** — a maioria dos executáveis tem grandes blocos de zeros no final ou entre funções.

# Redirecionamento

Vamos usar um exemplo do Wesnoth. Queremos que clicar em *Terrain Description* chame o menu de debug **e também** mostre a descrição de terreno normalmente (sem perder funcionalidade).

A instrução original do *Terrain Description* fica em:

```c++
0x00CCAF90 call dword ptr ds:[eax+28]    ; chama terrain description
```

Suponha que há memória vazia em `0x00D00000`. O processo:

**Passo 1:** Copiamos a instrução original para a cave:
```c++
0x00D00000 call dword ptr ds:[eax+28]
```

**Passo 2:** Substituímos o original por um salto para a cave:
```c++
0x00CCAF90 jmp 0x00D00000
```

**Passo 3:** No final da cave, voltamos para o código seguinte (`0x00CCAF93`):
```c++
0x00D00000 call dword ptr ds:[eax+28]
           jmp 0x00CCAF93
```

Resultado: o jogo salta para a cave, executa o que está lá, e volta exatamente onde parou.

# Preservando Registradores

Antes de adicionar código novo à cave, existe um risco: sua cave pode **modificar registradores** que o jogo está usando. Se o jogo esperava que `eax` tivesse um valor específico e você o mudou, o jogo pode travar.

Solução: **salvar e restaurar todos os registradores** antes e depois do seu código.

As instruções para isso:
- **`pushad`** — salva **todos** os registradores (eax, ebx, ecx, edx, esi, edi, ebp, esp) na pilha
- **`popad`** — restaura todos de volta

> **Metáfora:** Antes de mexer na bancada de trabalho de outra pessoa, você tira uma foto (pushad). Faz o que precisa. Depois recoloca tudo exatamente como estava (popad).

# Esqueleto da Cave

Com isso, temos o esqueleto padrão de toda code cave:

```c++
pushad                      ; salva todos os registradores
; ... seu novo código aqui ...
popad                       ; restaura todos os registradores
; instrução original aqui
jmp de_volta_ao_jogo        ; retorna ao fluxo original
```

Aplicando ao nosso exemplo com o debug menu (`call dword ptr ds:[eax+68]`):

```c++
0x00D00000 pushad
           call dword ptr ds:[eax+68]    ; invoca o menu de debug
           popad
           call dword ptr ds:[eax+28]    ; instrução original (terrain description)
           jmp 0x00CCAF93               ; volta ao jogo
```

**O que isso faz:**
1. Salva todos os registradores
2. Chama o menu de debug
3. Restaura os registradores (como se a chamada não tivesse acontecido)
4. Executa a instrução original normalmente
5. Volta ao fluxo do jogo

Resultado: as duas coisas acontecem — menu de debug **e** terrain description — sem quebrar nada.

> **Limite:** Desde que você restaure os registradores e a pilha corretamente, não há limite para a quantidade de código que você pode colocar numa cave. Esse é o poder do pattern pushad/popad.

&nbsp;