---
title: Usando Breakpoints
author: attilathedud
date: 2023-12-25
category: Debugging e Reversão
layout: post
---

# Contexto

Quando você anexa um debugger a um jogo pela primeira vez, a quantidade de código na tela pode parecer assustadora. Centenas de instruções assembly rolando sem parar.

O segredo é: **você não precisa entender tudo**. O que precisa é estabelecer um **contexto** — ou seja, encontrar um ponto de entrada relevante para o que você quer modificar. A partir desse ponto, você analisa apenas o que importa.

Como encontrar esse ponto? Com **breakpoints**.

# Breakpoints

Um **breakpoint** (ponto de interrupção) é como uma armadilha que você instala no código. Quando a execução do jogo chega àquela instrução específica, o debugger **pausa tudo** e você pode inspecionar o estado: registradores, memória, stack.

Breakpoints podem ser:
* **Incondicionais** — disparam sempre que a execução chega àquele ponto
* **Condicionais** — disparam apenas se uma condição for satisfeita (ex: um registrador tem um valor específico, ou uma área da memória foi modificada)

Quando um breakpoint dispara, dizemos que ele **"popou"** *(popped)*.

# Breakpoints de Memória

Uma das formas mais úteis de estabelecer contexto é usar um **memory breakpoint** (breakpoint de memória). A ideia: você diz ao debugger "pause quando alguém **ler ou escrever** nesse endereço de memória".

Imagine que, na [aula de Memory Hack](/pages/1/05/), encontramos o endereço de memória do nosso ouro. Agora queremos encontrar o código responsável por **diminuir** esse ouro quando recrutamos uma unidade.

O processo:
1. Coloque um breakpoint na **memória do ouro**
2. Vá ao jogo e recrute uma unidade
3. O game vai tentar escrever o novo valor de ouro naquele endereço → o breakpoint dispara
4. O debugger pausa na instrução que **modificou** o ouro

O código pausado pode parecer assim (a seta `->` marca onde a execução parou):

```c++
   mov eax, dword ptr ds:[0x05500ABC]    ; carrega o ouro atual
   mov ebx, dword ptr ds:[0x12345678]    ; carrega o custo da unidade
   sub eax, ebx                          ; subtrai o custo do ouro
-> mov dword ptr ds:[0x05500ABC], eax    ; salva o novo valor de ouro
   mov esi, ebx
```

> **Por que o breakpoint parou DEPOIS do `sub`?** Porque breakpoints de memória disparam após a instrução que **modificou** o valor em questão. O `sub` mudou apenas o registrador, não a memória. É o `mov` final que escreve de volta na RAM — e é aí que o breakpoint popa.

# Breakpoints de Código

E quando não existe uma variável de memória fácil de encontrar? Nesse caso, usamos um **code breakpoint** — que pausa na execução de uma instrução específica do código.

Um caso clássico: queremos criar um wallhack para um jogo. A função que desenha as paredes pode ser algo como:

```c++
void main_loop(){
    draw_players();
    draw_walls();
    ...
}

void draw_walls(){
    bool succeeded = load_texture("wall_texture");
    if(succeeded == false){
        print_error();
    }
}

void print_error(){
    print_to_log("Couldn't find wall texture");
}
```

Não temos um valor de memória óbvio para setar um breakpoint. Mas temos um **texto** que aparece em `print_error`: *"Couldn't find wall texture"*.

Debuggers como o x64dbg permitem buscar todas as strings (textos) dentro de um executável e ver onde elas são referenciadas. Você pode então setar um **code breakpoint** nessa referência.

Com o breakpoint instalado: force a situação onde a textura falta → o breakpoint para → você vê o código ao redor → **sobe na call stack** (a sequência de quem chamou quem) até chegar à função `draw_walls` que você quer remover.

Esse processo de "subir na hierarquia de chamadas" é fundamental em reversão.

# A Instrução NOP

**NOP** (opcode `0x90`) significa *No Operation* — **nenhuma operação**. Quando a CPU encontra um NOP, simplesmente ignora e vai para a próxima instrução. É como uma linha em branco no código.

> **Por que isso é poderoso?** Porque você pode substituir qualquer instrução por NOPs para **efetivamente removê-la**, sem quebrar o fluxo do programa.

Voltando ao exemplo do ouro. Encontramos o código:

```c++
mov eax, dword ptr ds:[0x05500ABC]
mov ebx, dword ptr ds:[0x12345678]
sub eax, ebx                         ; ← AQUI a subtração acontece
mov dword ptr ds:[0x05500ABC], eax
```

Se substituirmos o `sub eax, ebx` por NOPs, o jogo não vai mais subtrair o ouro. O valor em `eax` permanece inalterado e é salvo de volta — resultado: **ouro infinito**.

É exatamente isso que faremos na próxima aula!

&nbsp;