---
title: Derrotando a DMA
author: attilathedud
date: 2023-12-25
category: Debugging e Revers√£o
layout: post
---

# Alvo

Nosso alvo nesta aula √© o **Wesnoth 1.14.9**.

# Identificar

Nosso objetivo √© localizar o **ponteiro base** da classe `Player` no Wesnoth. Com ele, conseguimos sempre calcular onde est√° o ouro do jogador ‚Äî mesmo ap√≥s reiniciar o jogo.

# Entender

Quando um jogador inicia uma partida no Wesnoth, o jogo usa DMA para alocar os dados do jogo ‚Äî incluindo o ouro. O endere√ßo do ouro muda a cada partida.

Mas alguns valores **n√£o mudam** ‚Äî como o nome do perfil do jogador. Esses valores precisam estar sempre acess√≠veis, ent√£o ficam num **endere√ßo fixo**. Se encontrarmos esse endere√ßo fixo (o ponteiro base da classe `Player`), conseguimos seguir a cadeia de offsets at√© o ouro.

Imagine a estrutura das classes assim:

```c++
class Player {
    string player_name = "IEUser";
    int wins = 100;
    Game game = null;    // ponteiro para a partida atual
}

class Game {
    string side;
    int gold;     // ‚Üê √© isso que queremos
    int turn;
}
```

Quando o jogador entra numa partida:

```c++
player.game = new Game("Human", 100, 1);
```

O `new Game(...)` aloca mem√≥ria dinamicamente ‚Äî endere√ßo diferente a cada vez. Mas o `Player` em si √© fixo. Ent√£o:

- Encontramos o endere√ßo do ouro ‚Üí revertemos para encontrar o endere√ßo do `Game`
- Revertemos o `Game` ‚Üí encontramos o `Player`
- O `Player` tem endere√ßo fixo ‚Üí esse √© nosso ponteiro base!

# Localizando o Ouro

Pela **√∫ltima vez** nas primeiras aulas, precisamos encontrar o endere√ßo do ouro manualmente. Abra o Wesnoth, crie um jogo local. **Desta vez**, certifique-se de habilitar a op√ß√£o *Income* (renda por turno) e que o segundo jogador seja um computador:

![Op√ß√£o de Renda no Wesnoth](/assets/images/2/9/wesnoth1.png)

Use o [Memory Hack](/pages/1/05/) para encontrar o endere√ßo do ouro e feche o Cheat Engine (mantenha o Wesnoth aberto).

# Encontrando o Ponteiro Base

Annexe o x64dbg ao Wesnoth e sete um breakpoint de escrita no endere√ßo do ouro. Desta vez, **n√£o recrute uma unidade**. Em vez disso, **termine seu turno** ‚Äî o jogo adicionar√° renda ao ouro, disparando o breakpoint:

![Breakpoint Disparado pela Renda](/assets/images/2/9/wesnoth2.png)

Examine a instru√ß√£o que disparou o breakpoint:

```c++
009B4D00 add dword ptr ds:[eax+4], edx
```

Quando isso executa, `eax+4` cont√©m o endere√ßo do ouro (ex: `0x0D70B9AC`). Nosso pr√≥ximo passo √© descobrir de onde `eax` vem. Olhando acima dessa instru√ß√£o, h√° v√°rios `mov` e um `call`. Para verificar se essa fun√ß√£o define `eax`, sete um breakpoint nela e termine o turno novamente:

![Breakpoint Disparado pela Renda](/assets/images/2/9/wesnoth3.png)

`eax` vale 0 ao entrar na fun√ß√£o ‚Äî confirmando que ela √© respons√°vel por buscar o valor. D√™ **Step Over** para confirmar que `eax` muda ap√≥s a fun√ß√£o:

![Breakpoint Disparado pela Renda](/assets/images/2/9/wesnoth4.png)

Agora entre na fun√ß√£o com **Step Into** e siga o c√≥digo. Voc√™ ver√° que `eax` √© definido com base em `ecx + 60`:

![Breakpoint Disparado pela Renda](/assets/images/2/9/wesnoth5.png)

Continuando pela fun√ß√£o, voc√™ ver√° `0xA90` sendo adicionado a `eax`, e depois `edx` recebendo `eax + 4`. Avance at√© o ponto onde o valor de `ecx` entra:

![Breakpoint Disparado pela Renda](/assets/images/2/9/wesnoth6.png)

Com isso mapeado, sabemos que: **`[[ecx + 60] + 0xA90] + 4`** √© o endere√ßo do ouro. Agora precisamos verificar se `ecx` √© um ponteiro est√°vel.

**Verifica√ß√£o do ponteiro base:**

1. Anote o valor atual de `ecx` (ex: `0x017EECB8`) e o endere√ßo da instru√ß√£o que o define (ex: `0x009AE7F7`)
2. Desanexe o x64dbg, feche e reabra o Wesnoth
3. Reanexa o x64dbg, sete um breakpoint em `0x009AE7F7`, termine um turno
4. Observe se o valor de `ecx` √© o mesmo

Se for o mesmo ‚Äî **encontramos o ponteiro base!** Ele n√£o muda entre sess√µes.

# Usando o Ponteiro Base

Com o ponteiro base `0x017EECB8` e os offsets `+0x60, +0xA90, +4`, o ouro do jogador est√° sempre em:

```
[[0x017EECB8 + 0x60] + 0xA90] + 4
= [[0x017EED18] + 0xA90] + 4
```

Podemos verificar isso no Cheat Engine com *Add Address Manually*:

![Fun√ß√£o de Adicionar Endere√ßo Manualmente do Cheat Engine](/assets/images/2/9/wesnoth7.png)

Marque o checkbox *Pointer*, insira `0x017EED18` como endere√ßo base, `0xA90` como primeiro offset, e `4` como segundo offset:

![Configura√ß√£o de Ponteiro no Cheat Engine](/assets/images/2/9/wesnoth8.png)

O Cheat Engine vai exibir o valor atual do seu ouro no campo de endere√ßo. Se fechar e reabrir o Wesnoth, o ponteiro se atualizar√° automaticamente para o novo endere√ßo din√¢mico ‚Äî e o valor do ouro continuar√° correto.

**Voc√™ derrotou a DMA!** üéâ Na pr√≥xima aula, vamos usar esses valores para programar um hack externo em C++.

&nbsp;
