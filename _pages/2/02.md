---
title: Fundamentos de Assembly
author: attilathedud
date: 2023-12-25
category: Debugging e Reversão
layout: post
---

# Visão Geral

Na aula anterior, mencionamos que ao debugar um jogo, você vai lidar principalmente com **instruções assembly**. Existem dezenas de instruções, mas para reverter jogos, você vai usar um conjunto bem pequeno delas. O objetivo desta aula é apresentar as mais comuns.

Pense no assembly como uma **linguagem de ordens curtas** para o processador. Cada instrução é uma ordem simples: "mova isso", "some aqui", "compare aqueles dois". A CPU obedece uma por uma, na sequência.

# Gerenciamento de Dados

A instrução mais fundamental é o **mov** — ela **move** (copia) um valor de um lugar para outro. Alguns exemplos:

```c++
mov eax, ecx    ; copia o valor de ecx para eax
mov eax, 1      ; coloca o número 1 em eax
```

Também podemos usar o **mov** para carregar dados diretamente da memória (RAM) para um registrador:

```c++
mov eax, dword ptr ds:[0x12345678]
```

Tradução: "mova para **eax** o valor de 4 bytes (*dword*) que está no endereço de memória `0x12345678`."

> **Metáfora:** Imagine a RAM como uma série de caixinhas numeradas. Cada caixinha tem um endereço. O `mov` é como pegar o conteúdo de uma caixinha e colocar na mão (o registrador).

Quando trabalhamos com **classes** (como vimos na aula de Fundamentos de Jogos), os jogos precisam primeiro carregar o **endereço** de onde um objeto está na memória. Para isso, existe o **lea** (*Load Effective Address* — carregar endereço efetivo):

```c++
lea eax, dword ptr ds:[ecx]
```

Diferente do `mov`, o `lea` não traz o **conteúdo** — ele traz o próprio **endereço** armazenado em ecx.

# Modificando Dados

Depois de carregar um valor num registrador, você pode modificá-lo:

**Incrementar / Decrementar por 1:**
```c++
inc eax    ; eax = eax + 1
dec eax    ; eax = eax - 1
```

**Somar / Subtrair:**
```c++
add eax, 2      ; eax = eax + 2
add eax, ebx    ; eax = eax + ebx
sub eax, 4      ; eax = eax - 4
```

**Multiplicar / Dividir** (operam sempre sobre `eax`):
```c++
mul 4    ; eax = eax × 4
div 4    ; eax = eax ÷ 4
```

**Operações bit a bit** (usadas para manipular bits individuais):
```c++
shl eax, 2    ; desloca bits para a esquerda (equivale a multiplicar por 4)
shr eax, 2    ; desloca bits para a direita (equivale a dividir por 4)
and eax, eax  ; AND bit a bit
or eax, ebx   ; OR bit a bit
xor eax, eax  ; XOR — quando feito com o mesmo registrador, zera eax (truque clássico!)
```

# Controle de Fluxo

Os jogos são compostos por centenas de funções. Para navegar entre elas, existem instruções de **controle de fluxo**:

**Saltar para um endereço** (*jump*):
```c++
jmp 0x12345678    ; vai para o endereço e continua dali
```

**Chamar uma função** (*call*):
```c++
call 0x12345678   ; chama a função no endereço e retorna ao terminar
```

A diferença principal: o `jmp` é uma viagem sem volta. O `call` vai até a função, executa tudo, e depois **retorna** para onde estava. É como a diferença entre mudar de endereço e fazer uma visita.

Para **comparar valores** e decidir para onde pular:
```c++
cmp eax, 2      ; compara eax com 2
test eax, eax   ; compara eax consigo mesmo (resultado: é zero ou não?)
```

O `cmp` e o `test` não modificam nenhum registrador — eles apenas **levantam flags** (bandeirinhas internas da CPU) indicando o resultado. Depois, uma instrução de salto condicional usa essas flags:

```c++
cmp eax, ebx
jz 0x12345678    ; pula se ZERO (se eax == ebx)
```

As condicionais mais comuns em reversão de jogos:

| Instrução | Significado |
|---|---|
| `jz` / `je` | Pula se igual (Zero Flag) |
| `jnz` / `jne` | Pula se diferente (Not Zero) |
| `jg` | Pula se maior (Greater) |
| `jl` | Pula se menor (Less) |

# A Pilha (Stack)

Além dos registradores, os programas guardam informações temporárias em uma estrutura chamada **pilha** (*stack*). Ela funciona como uma **pilha de pratos**: você coloca algo por cima (**push**) e retira do topo (**pop**).

```c++
push 5      ; coloca 5 no topo da pilha
pop eax     ; retira o topo (5) e coloca em eax
```

Antes de chamar uma função que precisa de parâmetros, o jogo empurra esses parâmetros na pilha:

```c++
push 5
push eax
call 0x12345678    ; a função recebe 5 e o valor de eax como parâmetros
```

Toda função típica começa com um **prólogo** (preparação) e termina com um **epílogo** (limpeza):

```c++
; PRÓLOGO — início da função:
push ebp
mov ebp, esp
sub esp, ...

; ... código da função ...

; EPÍLOGO — fim da função:
leave
ret
```

O prólogo cria um "espaço de trabalho" local para a função (chamado de *stack frame*). O epílogo restaura o estado anterior e retorna para quem chamou a função.

# Exemplo Completo

Vamos juntar tudo. O código abaixo é o que você poderia ver num debugger ao reverter a lógica de vidas de um jogo:

```c++
            mov eax, dword ptr ds:[0x12345678]    ; carrega as vidas do jogador
            sub eax, 1                             ; subtrai 1 vida
            mov dword ptr ds:[0x12345678], eax     ; salva o novo valor
            test eax, eax                          ; o resultado é zero?
            jz 0x22222222                          ; se sim (= 0 vidas), vai para Game Over
            jmp 0x22222200                         ; se não, volta ao loop normal
0x22222222: mov ecx, ebx
            push 5
            push ecx
            call 0x45923821                        ; chama a função que exibe "Game Over"
```

Lendo instrução por instrução:
1. Carrega as vidas atuais em `eax`
2. Subtrai 1
3. Salva de volta na memória
4. Verifica se é zero (jogador perdeu todas as vidas?)
5. Se sim → pula para a seção que exibe o Game Over
6. Se não → volta ao loop do jogo

Isso é reversão de programa. Você lê o assembly, entende o que cada bloco faz, e eventualmente consegue reconstruir a lógica na sua cabeça (e modificá-la!).

&nbsp;
