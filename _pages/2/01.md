---
title: Fundamentos de Debugging
author: attilathedud
date: 2023-12-25
category: Debugging e Reversão
layout: post
---

# Contexto

Na aula anterior, modificamos nosso ouro alterando uma variável na memória. Funciona muito bem — mas tem limitações. Nem todo hack pode ser feito simplesmente encontrando um valor e mudando.

Por exemplo: e se quiséssemos criar um hack para recrutar unidades **sem gastar ouro**? Uma abordagem seria monitorar o ouro constantemente e aumentá-lo sempre que diminuísse. Mas isso é trabalhoso e frágil.

A abordagem mais elegante é **modificar o código do jogo diretamente** — especificamente a parte responsável por diminuir o ouro quando você recruta. É aí que entram o **debugging** e a **reversão**.

* **Debugging** = examinar o código do jogo enquanto ele está sendo executado
* **Reversão** (*reversing*) = entender o que esse código faz e modificá-lo para o que queremos

Você não precisa necessariamente usar um debugger para reverter um programa — mas ajuda muito.

# Ferramentas

Para debugar um jogo, usamos um programa chamado **debugger** (depurador). O primeiro passo é "anexar" o debugger ao processo do jogo. Com ele anexado, você pode:

* **Ver o código** do jogo em memória (em formato assembly)
* **Pausar a execução** do jogo em qualquer momento
* **Step through** (avançar instrução por instrução)
* **Modificar registradores e memória** em tempo real

> ⚠️ **Aviso:** Debuggers podem causar efeitos colaterais. Se você modificar o código incorretamente, o jogo pode travar — e em alguns casos, congelar a tela inteira. Por isso reforçamos sempre: **use sua VM, nunca sua máquina pessoal**.

Existem vários debuggers disponíveis. Alguns nomes que você vai encontrar:

| Debugger | Status | Observação |
|---|---|---|
| **x64dbg** | ✅ Ativo (recomendado) | Gratuito, open source, suporta 32 e 64 bits |
| **Ghidra** | ✅ Ativo | Desenvolvido pela NSA, gratuito, ótimo para análise estática |
| **IDA Free** | ✅ Ativo (versão gratuita) | Referência da indústria, mas a versão paga é cara |
| **WinDbg** | ⚠️ Mantido pela Microsoft | Mais voltado para análise de kernel e drivers |
| **OllyDbg** | ❌ Descontinuado | Ainda mencionado em tutoriais antigos, mas **não use** — não suporta 64 bits |

Neste curso, usaremos o **x64dbg**. As técnicas que você aprender aqui se aplicam a qualquer debugger — o importante são os conceitos, não a ferramenta.

# Disassembly e Debugging

Quando você anexa um debugger a um jogo, ele mostra o **código sendo executado**. Mas atenção: esse não é o código-fonte original (em C++ ou C#). O executável do jogo contém apenas **opcodes** — os números que a CPU executa diretamente.

O processo de converter opcodes de volta para algo mais legível (assembly) chama-se **disassembly** (desmontagem). É como tentar reconstruir uma receita a partir do prato pronto — você consegue ter uma ideia, mas não com perfeição.

Existem duas formas de analisar um programa:

* **Análise dinâmica** — usar um debugger com o programa rodando (ele executa o código enquanto você observa)
* **Análise estática** — examinar o programa **sem executá-lo**, usando um disassembler como o Ghidra

Em hacking de jogos, geralmente combinamos as duas.

> **Decompiladores** (como o Ghidra) tentam reconstruir o código C++ original a partir dos opcodes. Isso é útil, mas o resultado é sempre uma estimativa — cheio de nomes gerados automaticamente como `FUN_00401234`. Pode induzir ao erro se você confiar cegamente neles. Para este curso, focaremos em assembly.

# Assembly

Ao debugar e reverter um jogo, você vai lidar principalmente com **assembly** — a linguagem de baixo nível que vimos na aula de Fundamentos de Computação.

Cada instrução faz uma coisa só. Não é necessário memorizar todas as instruções existentes. A boa notícia: você consegue entender qualquer bloco de código assembly se avançar **uma instrução por vez** e observar o que muda.

Quando fazemos isso com um debugger, chamamos de **stepping through the disassembly** — e será exatamente o que vamos praticar nas próximas aulas.

Existe muito código num jogo que você pode simplesmente **ignorar** durante a reversão. Por exemplo: a CPU faz diversas instruções auxiliares ao trabalhar com números decimais, mas se você só quer o resultado final, pode pular vedo tudo isso. Saber o que pular vem com a prática.

&nbsp;