---
title: Alocação Dinâmica de Memória (DMA)
author: attilathedud
date: 2023-12-25
category: Debugging e Reversão
layout: post
---

# Visão Geral

Nas aulas anteriores, toda vez que reiniciávamos o Wesnoth, precisávamos repetir o processo de encontrar o endereço do ouro — porque ele mudava. Isso acontece por causa da **DMA** (Dynamic Memory Allocation — Alocação Dinâmica de Memória).

Para criar hacks que possam ser reutilizados e distribuídos, precisamos superar a DMA e converter esses endereços "aleatórios" em endereços consistentes.

# Por Que a DMA Existe?

Como vimos na aula de Fundamentos de Jogos, jogos são programas enormes com recursos imensos. Não é possível carregar tudo na RAM de uma vez — então os jogos **carregam e descarregam dados sob demanda**.

Por exemplo: um jogo não carrega o modelo 3D de um inimigo até o jogador estar prestes a encontrá-lo. Quando o encontro termina, esse modelo pode ser descarregado para liberar memória.

> **Metáfora:** Imagine que a RAM é uma mesa de trabalho com espaço limitado. Você não coloca todos os seus livros, ferramentas e documentos na mesa de uma vez. Você vai buscar o que precisa, usa, e devolve ao baú (HD). A DMA é exatamente esse processo de "pegar e devolver" para o computador.

Esse processo de criação de espaço na RAM chama-se **alocação**; de liberação chama-se **desalocação**. O sistema operacional decide onde cada bloco de memória vai ficar — o jogo não controla isso. Por isso, cada vez que o Wesnoth é iniciado, o ouro do jogador termina num endereço diferente.

No Wesnoth específicamente: quando você inicia um novo jogo, uma classe `Game` é criada com valores como ouro, raça e unidades. Quando você sai, essa classe é destruída. A próxima vez que você jogar, ela será criada num local diferente da RAM.

# Métodos para Superar a DMA

Existem três abordagens principais:

| Método | Quando usar |
|---|---|
| **Scanner automático (Cheat Engine)** | Rápido, ideal para testes manuais |
| **Code Cave** | Quando você quer salvar o endereço automaticamente durante a execução |
| **Reversão** | Mais trabalhoso, mas o mais robusto e programável |

### Cheat Engine — Pointer Scan

O Cheat Engine tem uma função de **pointer scan** (varredura de ponteiro). Você a encontra clicando com botão direito no endereço encontrado:

![Função de Pointer Scan do Cheat Engine](/assets/images/2/8/CheatEngine1.png)

Ela retorna **todos os endereços que atualmente apontam para o seu endereço**. Você salva os resultados, reinicia o jogo, encontra o endereço novamente e faz uma nova comparação. O que sobrar são ponteiros que **sempre** apontam para seu valor — seu ponteiro base!

### Code Cave

Com uma code cave, você encontra uma instrução que acessa o valor que quer monitorar (como o ouro) e redireciona o código para uma cave. Dentro da cave, você **salva o endereço atual em um local que você controla**.

```c++
pushad
mov dword ptr ds:[0x12345678], edx+4    ; salva o endereço do ouro num local fixo
popad
...instrução original...
jmp 0xlocal_de_retorno
```

A partir daí, seu hack sempre consulta `0x12345678` para obter o endereço dinâmico do ouro.

### Reversão

É a abordagem mais completa. Você analisa o código do jogo para entender toda a cadeia de ponteiros que leva até o valor que quer. O objetivo é chegar num **endereço base** — um endereço que **nunca muda** entre sessões.

O processo:
1. Encontre uma instrução que acessa o valor (ex: o `sub` do ouro)
2. Descubra de qual registrador e qual offset esse valor vem
3. Suba na hierarquia de funções para descobrir de onde esse registrador vem
4. Repita até encontrar um endereço que não muda entre reinícios

O endereço estável que você chegar é o **ponteiro base** (*base pointer*). Com ele e os offsets que você mapeou, você sempre consegue chegar ao valor dinâmico — mesmo que ele mude de endereço a cada sessão.

> **Na próxima aula**, vamos fazer exatamente isso com o ouro do Wesnoth!

&nbsp;