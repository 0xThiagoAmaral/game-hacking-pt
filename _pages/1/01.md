---
title: Fundamentos de Computa√ß√£o
author: attilathedud
date: 2023-12-25
category: Fundamentos
layout: post
---

# Componentes de um Computador

Um computador t√≠pico √© composto por v√°rios componentes conectados entre si. Os mais importantes s√£o:

* HD / SSD (armazenamento)
* RAM (mem√≥ria)
* Placa de v√≠deo
* Placa-m√£e
* CPU (processador)

Se voc√™ tirasse a lateral de um computador desktop, os componentes estariam dispostos mais ou menos assim:

![Partes de um Computador](/assets/images/1/1/Computer.png)

Por enquanto, vamos dar uma aten√ß√£o breve aos primeiros quatro, e depois focaremos todo o nosso estudo na CPU:

* **HD/SSD** ‚Äî pense nele como um **arm√°rio**. Guarda tudo: fotos, jogos, arquivos do sistema. Mas acessar coisas no arm√°rio √© demorado.
* **RAM** ‚Äî pense nela como sua **mesa de trabalho**. Voc√™ coloca l√° apenas o que est√° usando agora. Muito mais r√°pida que o HD, mas o espa√ßo √© limitado.
* **Placa de v√≠deo** ‚Äî respons√°vel por desenhar imagens e gr√°ficos na tela.
* **Placa-m√£e** ‚Äî a espinha dorsal do computador. Conecta todos os outros componentes e permite que eles se comuniquem.

# A CPU

A CPU √© o c√©rebro do computador. √â ela quem de fato **executa as instru√ß√µes** dos programas. Essas instru√ß√µes s√£o bem simples ‚Äî por exemplo, "somar dois n√∫meros". Para trabalhar mais r√°pido, a CPU tem pequenas √°reas de armazenamento internas chamadas **registradores** (ou *registers*), onde ela guarda e manipula dados temporariamente.

Pense nos registradores como as **m√£os** da CPU: ela precisa pegar um dado, process√°-lo e coloc√°-lo em algum lugar ‚Äî e ela faz isso com os registradores.

![Diagrama da CPU](/assets/images/1/1/CPU.png)

# Instru√ß√µes

Todos os programas de computador s√£o feitos de uma sequ√™ncia de instru√ß√µes. Como vimos, cada instru√ß√£o √© simples e normalmente faz apenas uma coisa. Alguns exemplos de instru√ß√µes comuns em v√°rias arquiteturas:

* Somar dois n√∫meros
* Subtrair dois n√∫meros
* Comparar dois n√∫meros
* Mover um n√∫mero para uma √°rea da mem√≥ria (RAM)
* Ir para outra parte do c√≥digo

Os programas surgem quando essas instru√ß√µes simples s√£o combinadas. Uma calculadora b√°sica, por exemplo, poderia ser escrita assim em *assembly* (a linguagem mais pr√≥xima do que o processador realmente entende):

```c++
mov eax, 5
mov ebx, 4
add eax, ebx
```

A primeira instru√ß√£o (**mov**) coloca o valor 5 no registrador **eax**. A segunda coloca 4 em **ebx**. Por fim, **add** soma os dois e coloca o resultado de volta em **eax**.

# Programas de Computador

Um programa de computador recebe uma entrada (*input*), processa essa informa√ß√£o seguindo um conjunto de instru√ß√µes, e produz uma sa√≠da (*output*).

Por exemplo, imagine um programa que recebe um n√∫mero, adiciona 1, e devolve o resultado:

```c++
mov eax, input
add eax, 1
mov output, eax
```

Programas mais complexos t√™m v√°rios desses "programas menores" dentro deles. Esses sub-programas s√£o chamados de **fun√ß√µes** (*functions*). Uma fun√ß√£o funciona igual a um programa: recebe uma entrada e produz uma sa√≠da. Nosso exemplo como fun√ß√£o:

```c++
function add(input):
    mov eax, input
    add eax, 1
    mov output, eax
```

Podemos fazer outra fun√ß√£o para subtrair:

```c++
function subtract(input):
    mov eax, input
    sub eax, 1
    mov output, eax
```

Com essas duas fun√ß√µes, podemos criar um programa que soma **ou** subtrai dependendo do que o usu√°rio pedir:

```c++
function add(input):
    mov eax, input
    add eax, 1
    mov output, eax

function subtract(input):
    mov eax, input
    sub eax, 1
    mov output, eax

cmp operation, '-'
je subtract_number
add(number)
exit

subtract_number:
    subtract(number)
    exit
```

A instru√ß√£o **cmp** compara dois valores ‚Äî no caso, o tipo de opera√ß√£o recebida com o s√≠mbolo `-`. Se forem iguais, pulamos para o c√≥digo de subtra√ß√£o (**je** = *jump if equal*, pular se igual). Caso contr√°rio, continuamos somando.

Esse conceito de "comparar e pular para um c√≥digo diferente dependendo do resultado" se chama **ramifica√ß√£o** (*branching*). √â uma ideia fundamental em programa√ß√£o ‚Äî e em jogos, ela aparece o tempo todo (por exemplo: "se o jogador apertou a tecla esquerda, mova o personagem para a esquerda").

# Bin√°rio, Decimal e Hexadecimal

No fundo, a CPU √© um circuito el√©trico. Circuitos s√≥ entendem dois estados: com eletricidade passando (**ligado**) ou sem (**desligado**). Por isso, computadores usam o sistema **bin√°rio** (base 2), onde s√≥ existem dois valores: 0 e 1. Um n√∫mero bin√°rio de exemplo: `1101`.

N√≥s usamos o sistema **decimal** (base 10) no dia a dia, com os valores 0 a 9. O n√∫mero 126 em decimal pode ser escrito como:

$$ (1 \times 10^2) + (2 \times 10^1) + (6 \times 10^0) $$

O n√∫mero bin√°rio `1101` segue a mesma l√≥gica, mas trocando 10 por 2:

$$ (1 \times 2^3) + (1 \times 2^2) + (0 \times 2^1) + (1 \times 2^0) $$

N√∫meros bin√°rios ficam enormes quando representam valores grandes. Por exemplo, o decimal 250 em bin√°rio √© `11111010` ‚Äî dif√≠cil de ler. Para resolver isso, computadores usam o sistema **hexadecimal** (base 16), com 16 valores poss√≠veis: 0‚Äì9 e A‚ÄìF. N√∫meros hexadecimais geralmente come√ßam com `0x`. Exemplo: `0xA1D`.

Traduzindo: `0xFF` em hexadecimal = 255 em decimal. Voc√™ vai ver muito `0x` neste curso ‚Äî j√° pode ir se acostumando!

# Linguagens de Programa√ß√£o

As instru√ß√µes s√£o representadas como n√∫meros, assim como todos os outros dados no computador. Esses n√∫meros s√£o chamados de **opcodes** (*operation codes* ‚Äî c√≥digos de opera√ß√£o). Cada arquitetura tem seus pr√≥prios opcodes. Por exemplo, quando uma CPU Intel encontra o valor `0xE9`, ela sabe que precisa executar um **jmp** (pular para outro ponto do c√≥digo).

Antigamente, programadores escreviam programas diretamente em opcodes ‚Äî um trabalho extremamente tedioso. Depois surgiu a linguagem **assembly**, que usa palavras como `mov`, `add` e `jmp` no lugar de n√∫meros crus. Ainda √© complicado, mas j√° √© mais leg√≠vel.

Para tornar tudo mais f√°cil, surgiram as **linguagens de alto n√≠vel** como C, C++ e Rust. Elas s√£o mais pr√≥ximas do ingl√™s e t√™m estruturas como `if`, `else` e `for`. Nosso programa de incremento/decremento em C ficaria assim:

```c++
int add(int input) {
    return input + 1;
}

int subtract(int input) {
    return input - 1;
}

if(operation == '-') {
    subtract(number);
}
else {
    add(number);
}
```

Toda essa linguagem de alto n√≠vel √© "compilada" ‚Äî ou seja, transformada em assembly e depois em opcodes que o processador entende.

> **Em 2026**, as linguagens mais usadas em desenvolvimento de jogos s√£o C++ (performance m√°xima) e C# (Unity). Game hacking usa principalmente C++ e Python. Assembly continua sendo essencial para entender o que acontece por baixo dos panos.

# Sistemas Operacionais

Escrever programas que se comunicam diretamente com o hardware √© extremamente dif√≠cil. Os **sistemas operacionais** (como Windows, Linux e macOS) existem para simplificar isso ‚Äî eles trazem c√≥digo pronto para lidar com teclado, mouse, tela, mem√≥ria e disco. Em vez de escrever tudo do zero, voc√™ usa as fun√ß√µes que o sistema operacional j√° oferece.

Isso tamb√©m explica por que programas feitos para Windows n√£o funcionam no Linux: cada sistema tem suas pr√≥prias "regras" e bibliotecas para se comunicar com o hardware.

# Aplicativos

Quando voc√™ clica duas vezes num arquivo no Windows, o sistema precisa decidir o que fazer com ele. Se for uma foto, abre o visualizador de imagens. Se for um programa, passa para a CPU executar.

No Windows, os programas s√£o formatados num padr√£o especial chamado **PE** (*Portable Executable*). Esse formato define se√ß√µes como:
- **`.text`** ‚Äî cont√©m o c√≥digo (os opcodes)
- **`.data`** ‚Äî cont√©m vari√°veis e dados est√°ticos

√â como se o formato PE fosse a "embalagem padronizada" que o Windows sabe como abrir.

# Jogos

Com tudo isso explicado, finalmente chegamos aos jogos! Jogos s√£o apenas aplicativos. No Windows, eles seguem o formato PE como qualquer outro programa. T√™m uma se√ß√£o `.text` com opcodes que o processador executa, e o sistema operacional cuida de exibir os gr√°ficos e processar os controles.

A √∫nica diferen√ßa √© que jogos s√£o muito mais complexos ‚Äî e muito mais divertidos de hackear. üòÑ

&nbsp;
