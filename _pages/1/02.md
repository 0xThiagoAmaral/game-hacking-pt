---
title: Fundamentos de Jogos
author: attilathedud
date: 2023-12-25
category: Fundamentos
layout: post
---

# As Partes de um Jogo

Jogos são aplicativos, mas são extremamente complexos. Eles são compostos por várias partes principais:

* Gráficos
* Sons
* Entrada do usuário (teclado, mouse, controle)
* Física
* Lógica do jogo

Cada uma dessas partes é tão complexa que a maioria dos jogos não "inventa a roda" — eles usam **bibliotecas** (*libraries*) externas. Uma biblioteca é um conjunto de funções prontas que você pode reaproveitar. Por exemplo, para desenhar imagens na tela a maioria dos jogos usa as bibliotecas **DirectX** (padrão no Windows, especialmente jogos modernos) ou **OpenGL** (mais portável, usado em jogos multiplataforma e mais antigos).

> **Por que isso importa para hacking?** Identificar qual biblioteca um jogo usa é o primeiro passo para criar certos tipos de hacks. Um *wallhack* — que permite ver jogadores através de paredes — pode ser criado manipulando exatamente essa camada gráfica.

# Estrutura de um Jogo

A lógica de um jogo — a parte que controla as regras, pontuação, posição dos jogadores, etc. — é escrita em código de alto nível (geralmente C++ ou C#) e depois compilada em instruções que o processador entende.

A maioria dos jogos tem duas grandes funções:

* **Setup (configuração)** — executada uma vez, quando o jogo inicia. Carrega imagens, sons e outros arquivos grandes do HD para a RAM.
* **Main Loop (laço principal)** — uma função que roda para sempre, até o jogador fechar o jogo. É o "coração" do jogo.

Um exemplo simplificado de main loop:

```c++
function main_loop() {
    handle_input();
    update_score();
    play_sound_effects();
    draw_screen();
}
```

Cada uma dessas funções chama outras funções. Por exemplo, o `handle_input` pode verificar qual tecla foi pressionada:

```c++
function handle_input() {
    if( keydown == LEFT ) {
        update_player_position(GO_LEFT);
    }
    else if( keydown == RIGHT ) {
        update_player_position(GO_RIGHT);
    }
}
```

Cada jogo é programado de forma diferente, mas todos têm algum tipo de main loop.

> **Em 2026**, a maioria dos jogos AAA usa engines como **Unreal Engine 5** (C++) ou **Unity 6** (C#). Ambas têm suas próprias implementações de main loop, mas o conceito é o mesmo.

# Dados e Classes

Qualquer valor que pode mudar num jogo — posição do jogador, dinheiro, vida, munição — fica guardado numa **variável**. Em C, declaramos variáveis assim:

```c++
int money = 0;
```

Isso cria a variável `money` do tipo inteiro, começando em 0.

Se precisarmos guardar o dinheiro de vários jogadores, poderíamos fazer:

```c++
int money1 = 0;
int money2 = 0;
int money3 = 0;
int money4 = 0;
```

Mas isso é difícil de manter. Imagine ter que adicionar suporte para mais um jogador — teria que mudar o código em vários lugares. A solução é usar uma **lista** (ou *array* em C):

```c++
int money[10] = { 0 };
int current_players = 4;

function increase_money() {
    for(int i = 0; i < current_players; i++) {
        money[i] = money[i] + 1;
    }
}
```

Assim, um **laço for** percorre todos os jogadores automaticamente. Para adicionar um novo jogador, basta mudar `current_players`.

Para projetos ainda maiores, os programadores usam a **Programação Orientada a Objetos (POO)**, onde variáveis e funções relacionadas são agrupadas em **classes**. Pense numa classe como uma **ficha de personagem**: agrupa nome, vida, dinheiro, habilidades — tudo em um lugar só.

Um exemplo de classe `Jogador`:

```c++
class Player {
    int money;
    string name;

    function increase_money() {
        money = money + 1;
    }
}
```

Os jogos frequentemente crêm listas de objetos dessas classes. Por exemplo, um servidor de Quake 3 mantinha um array com todos os jogadores conectados, e cada um tinha sua própria classe com kills, mortes, pontuação, etc.

# Memória

Jogos têm recursos muito grandes: texturas, sons, modelos 3D. Durante o *setup*, esses arquivos são carregados do HD para a **RAM**. O código do jogo também fica na RAM. A CPU busca dados da RAM para os registradores quando precisa processá-los.

Esse acesso é geralmente feito com o comando `mov`:

```c++
function increase_money:
    mov eax, 0x12345678   ; carrega o valor do dinheiro da RAM
    add eax, 1             ; soma 1
    mov 0x12345678, eax   ; salva de volta na RAM
```

Aqui, `0x12345678` é o **endereço de memória** onde o dinheiro do jogador está guardado. Para jogos mais complexos, esse endereço depende de outros endereços. Se o jogo usa uma classe `Player`, o código precisa primeiro saber o endereço da classe e depois calcular o deslocamento do campo `money`:

```c++
function increase_money:
    mov ebx, 0x12345670   ; endereço base da classe Player
    mov eax, ebx + 8      ; dinheiro está 8 bytes depois
    add eax, 1
    mov ebx+8, eax
```

> **Por que isso importa?** Descobrir esses endereços é exatamente o que fazemos num hack de memória. Ferramentas como o **Cheat Engine** ajudam a encontrá-los sem precisar ler o código diretamente.

# Clientes Multiplayer

Jogos multiplayer permitem que vários jogadores interajam. Para isso, usam o modelo **cliente-servidor**:

![Modelo Básico Cliente/Servidor](/assets/images/1/2/ClientServer.png)

Cada jogador roda um **cliente** — a cópia local do jogo com as informações daquele jogador. Quando algo muda (por exemplo, o jogador ganhou dinheiro), o cliente envia essa atualização para o servidor.

As informações fluem nos dois sentidos. Quando um jogador se move, seu cliente avisa o servidor, e o servidor avisa todos os outros clientes para atualizar a posição desse jogador na tela deles.

# Servidores Multiplayer

O **servidor** é o árbitro. Ele garante que todos os clientes estejam "jogando o mesmo jogo" e rejeita mudanças suspeitas. 

Por exemplo: se você hackear o seu dinheiro localmente, o servidor provavelmente vai recusar a mudança — afinal, ele sabe que você não deveria ter aquela quantia. É por isso que hacks de single-player geralmente não funcionam em multiplayer.

> **Em 2026**, servidores modernos têm validação rigorosa do lado do servidor (*server-side validation*), anti-cheats avançados como **EasyAntiCheat (EAC)**, **BattlEye** e **Riot Vanguard** — além de sistemas de detecção comportamental por IA. É cada vez mais difícil enganar um servidor moderno.

&nbsp;