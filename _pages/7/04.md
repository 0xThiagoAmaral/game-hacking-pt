---
title: Disassembler
author: attilathedud
date: 2023-12-25
category: Tool Development
layout: post
---

# Alvo

Nosso alvo é o **Wesnoth 1.14.9**.

# Visão Geral

O x64dbg exibe instruções como `mov eax, ebx`. Mas os executáveis armazenam essas instruções como **opcodes** (bytes). A conversão de opcodes para instruções se chama **disassembly**.

Nesta aula, criaremos um disassembler simplificado para entender como esse processo funciona. Para um disassembler completo, use o [Capstone Engine.](https://www.capstone-engine.org/)

> **Aviso:** Escrever um disassembler completo é extremamente complexo. O objetivo desta aula é apenas explicar os conceitos fundamentais.

# Como Funciona

Cada opcode mapeia para uma instrução. Por exemplo:
- `0xE8` → `CALL`
- `0x89` → `MOV`
- `0x29` → `SUB`

Esse mapeamento está definido no **Intel IA-32 Instruction Set Reference** — o manual oficial da Intel. A referência [ref.x86asm.net](http://ref.x86asm.net/coder64.html) é uma versão mais fácil de consultar.

# Lendo os Opcodes do Wesnoth

Usamos o mesmo código do [Pattern Scanner](/pages/7/02/) para ler o módulo `wesnoth.exe` para um buffer:

```c++
#define START_ADDRESS 0x7ccd91

unsigned int i = START_ADDRESS - (DWORD)me32.modBaseAddr;
while (i < START_ADDRESS + 0x50 - (DWORD)me32.modBaseAddr) {
    printf("%x:", i + (DWORD)me32.modBaseAddr);
    // analisar opcode em buffer[i]
    i++;
}
```

# Decodificando Instruções Simples

Para instrução `ADD` (opcode `0x01`), sabemos que tem 2 bytes (opcode + operando):

```c++
switch (buffer[i]) {
    case 0x1:
        printf("ADD ");
        i++;
        i += decode_operand(buffer, i);    // decodifica os registradores
        break;
    case 0x89:
        printf("MOV ");
        i++;
        i += decode_operand(buffer, i);
        break;
    default:
        printf("%x", buffer[i]);
        i++;
        break;
}
```

# Decodificando Operandos (ModR/M)

Logo após o opcode vem o byte **ModR/M** que indica os registradores. A tabela 2-2 do manual Intel explica o formato.

Para valores de `0xC0` a `0xFF` (registrador a registrador):
- **Bits 0-2** (via `% 8`) → registrador destino
- **Bits 3-5** (via `>> 3 % 8`) → registrador origem

```c++
const char modrm_value[8][4] = {
    "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"
};

int decode_operand(unsigned char* buffer, int location) {
    if (buffer[location] >= 0xC0 && buffer[location] <= 0xFF) {
        printf("%s, %s",
            modrm_value[buffer[location] % 8],          // primeiro registrador
            modrm_value[(buffer[location] >> 3) % 8]);  // segundo registrador
        return 1;
    }
    // operando com deslocamento (ex: [ebp - 0x388])
    else if (buffer[location] >= 0x80 && buffer[location] <= 0xBF) {
        DWORD displacement = buffer[location+1] | (buffer[location+2] << 8) |
                             (buffer[location+3] << 16) | (buffer[location+4] << 24);
        printf("[%s+%x], %s",
            modrm_value[buffer[location] % 8],
            displacement,
            modrm_value[(buffer[location] >> 3) % 8]);
        return 5;    // 1 byte ModR/M + 4 bytes de deslocamento
    }
    return 1;
}
```

# Calls e Jumps

O opcode `E8` (CALL) codifica o endereço como `(destino - posição_atual - 5)`. Para reverter:

```c++
case 0xE8:
    printf("CALL ");
    i++;
    loc = buffer[i] | (buffer[i+1] << 8) | (buffer[i+2] << 16) | (buffer[i+3] << 24);
    printf("%x", loc + (i + (DWORD)me32.modBaseAddr) + 4);
    i += 4;
    break;
```

Para `JE` (`0x74`), o segundo byte é o offset relativo:

```c++
case 0x74:
    printf("JE ");
    printf("%x", i + (DWORD)me32.modBaseAddr + 2 + buffer[i + 1]);
    i += 2;
    break;
```

# Resultado Final

Com os seguintes opcodes implementados (`ADD`, `MOV`, `SUB`, `JE`, `CALL`, `CMP`, `LEA`), o disassembler reproduz corretamente as instruções do Wesnoth:

![Resultado do Disassembler](/assets/images/7/4/dis12.png)

O código completo está no [GitHub](https://github.com/GameHackingAcademy/Disassembler).

&nbsp;
