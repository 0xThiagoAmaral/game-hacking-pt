---
title: DLL Injector
author: attilathedud
date: 2023-12-25
category: Tool Development
layout: post
---

# Alvo

Vamos criar um **DLL Injector** para o **Urban Terror** ‚Äî usaremos o wallhack de mem√≥ria que criamos na aula [Wallhack (Mem√≥ria)](/pages/5/02/).

# Vis√£o Geral

At√© agora usamos a chave de registro `AppInit_DLLs` para injetar DLLs. Esse m√©todo tem v√°rios problemas:

| Problema | Por qu√™ √© ruim |
|---|---|
| Precisar atualizar para cada nova DLL | Ineficiente |
| √â injetado em **todos** os processos | Interfer√™ncia inesperada |
| Exige desativar o Secure Boot | Inseguro |
| S√≥ funciona com processos que carregam `user32.dll` | Limitado |
| Carga acontece em hor√°rio fixo | Sem controle |

A solu√ß√£o: escrever um **injector** ‚Äî um programa que carrega nossa DLL manualmente num processo externo.

# Conceito Principal

Para for√ßar o jogo a carregar nossa DLL, usamos 3 APIs do Windows:

1. **`VirtualAllocEx`** ‚Üí aloca mem√≥ria no processo do jogo para guardar o caminho da DLL
2. **`WriteProcessMemory`** ‚Üí escreve o caminho da DLL na mem√≥ria alocada
3. **`CreateRemoteThread`** ‚Üí cria uma thread no processo do jogo que chama `LoadLibraryA` com o caminho da DLL

![Fluxo da Inje√ß√£o](/assets/images/7/1/injection1.png)

# Passo 1: Encontrando o Processo

Para interagir com o Urban Terror, precisamos do seu **handle**. Em vez de `FindWindow` (fr√°gil), usamos `CreateToolhelp32Snapshot`:

```c++
#include <windows.h>
#include <tlhelp32.h>

int main(int argc, char** argv) {
    HANDLE snapshot = 0;
    PROCESSENTRY32 pe32 = { 0 };
    pe32.dwSize = sizeof(PROCESSENTRY32);

    snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    Process32First(snapshot, &pe32);

    do {
        if (wcscmp(pe32.szExeFile, L"Quake3-UrT.exe") == 0) {
            // encontrou o Urban Terror!
        }
    } while (Process32Next(snapshot, &pe32));
}
```

`szExeFile` = nome do processo, `th32ProcessID` = ID do processo.

# Passo 2: Abrindo o Handle

```c++
HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, true, pe32.th32ProcessID);
```

# Passo 3: Alocando Mem√≥ria no Jogo

```c++
const char *dll_path = "C:\\Users\\IEUser\\source\\repos\\wallhack\\Debug\\wallhack.dll";
void *lpBaseAddress = VirtualAllocEx(
    process,
    NULL,
    strlen(dll_path) + 1,   // tamanho do caminho
    MEM_COMMIT,
    PAGE_READWRITE
);
```

> Note: backslashes em C++ precisam ser duplos (`\\` = um `\` real).

# Passo 4: Escrevendo o Caminho da DLL

```c++
WriteProcessMemory(process, lpBaseAddress, dll_path, strlen(dll_path) + 1, NULL);
```

# Passo 5: Criando a Thread Remota

```c++
HMODULE kernel32base = GetModuleHandle(L"kernel32.dll");

HANDLE thread = CreateRemoteThread(
    process,
    NULL,
    0,
    (LPTHREAD_START_ROUTINE)GetProcAddress(kernel32base, "LoadLibraryA"),
    lpBaseAddress,    // par√¢metro: o caminho da DLL
    0,
    NULL
);
```

# Passo 6: Aguardar e Limpar

```c++
WaitForSingleObject(thread, INFINITE);    // espera a inje√ß√£o terminar

// Libera mem√≥ria e handles
VirtualFreeEx(process, lpBaseAddress, 0, MEM_RELEASE);
CloseHandle(thread);
CloseHandle(process);
break;    // sai do loop de processos
```

Rode o Urban Terror, entre num jogo, execute o injector com permiss√µes de **administrador** ‚Äî os jogadores ficam vis√≠veis atrav√©s das paredes! üéØ

O c√≥digo completo est√° no [GitHub](https://github.com/GameHackingAcademy/DLL_Injector/).

&nbsp;