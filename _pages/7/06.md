---
title: Call Logger
author: attilathedud
date: 2023-12-25
category: Tool Development
layout: post
---

# Alvo

Nosso alvo √© o **Wesnoth 1.14.9**.

# Vis√£o Geral

Ao reverter jogos complexos, um dos maiores desafios √© **estabelecer um contexto** ‚Äî entender qual c√≥digo √© respons√°vel por qual funcionalidade. Uma abordagem eficaz: criar um **Call Logger** que registra todas as instru√ß√µes `CALL` executadas pelo jogo em tempo real.

Assim, voc√™ executa uma a√ß√£o no jogo (ex: recrutar uma unidade), observa todas as chamadas de fun√ß√µes registradas, e usa isso como ponto de partida para investigar.

<video controls autoplay loop>
  <source src="/assets/images/7/6/logger.mp4" />
</video>

O c√≥digo completo est√° no [GitHub](https://github.com/GameHackingAcademy/Call_Logger).

# Passo 1: Localizando o M√≥dulo Principal

Baseado no debugger da aula anterior ‚Äî mas agora para o `wesnoth.exe`. Ap√≥s anexar, na primeira exce√ß√£o de breakpoint (que ocorre automaticamente ao anexar), obtemos a localiza√ß√£o do m√≥dulo principal:

```c++
HMODULE modules[128] = { 0 };
MODULEINFO module_info = { 0 };
DWORD bytes_read = 0;

if (!first_break_has_occurred) {
    EnumProcessModules(process_handle, modules, sizeof(modules), &bytes_read);
    GetModuleInformation(process_handle, modules[0], &module_info, sizeof(module_info));
    // module_info.lpBaseOfDll = endere√ßo base do wesnoth.exe
    // module_info.SizeOfImage = tamanho do m√≥dulo
}
```

# Passo 2: Localizando todos os CALLs

Varremos o m√≥dulo em p√°ginas de 4096 bytes procurando pelo opcode `0xE8` (CALL). Para cada `0xE8` encontrado, verificamos se os 4 bytes seguintes apontam para um endere√ßo v√°lido dentro do m√≥dulo ‚Äî isso filtra falsos positivos (ex: `add eax, ebp` = `01 E8`):

```c++
#define READ_PAGE_SIZE 4096
unsigned char instructions[READ_PAGE_SIZE] = { 0 };

for (DWORD i = 0; i < module_info.SizeOfImage; i += READ_PAGE_SIZE) {
    ReadProcessMemory(process_handle, (LPVOID)((DWORD)module_info.lpBaseOfDll + i),
                      &instructions, READ_PAGE_SIZE, &bytes_read);

    for (DWORD c = 0; c < bytes_read; c++) {
        if (instructions[c] == 0xE8) {
            DWORD offset = (DWORD)module_info.lpBaseOfDll + i + c;
            DWORD call_location = 0;
            ReadProcessMemory(process_handle, (LPVOID)(offset + 1), &call_location, 4, &bytes_read);

            call_location += offset + 5;    // calcula destino do call

            // Verifica se √© um endere√ßo v√°lido dentro do m√≥dulo
            if (call_location < (DWORD)module_info.lpBaseOfDll ||
                call_location > (DWORD)module_info.lpBaseOfDll + module_info.SizeOfImage)
                continue;

            // Escreve breakpoint (INT 3) no CALL
            if (breakpoints_set < 2000) {
                WriteProcessMemory(process_handle, (void*)offset, &instruction_break, 1, &bytes_written);
                FlushInstructionCache(process_handle, (LPVOID)offset, 1);
                breakpoints_set++;
            }
        }
    }
}
```

> Limitamos a 2000 breakpoints ‚Äî escrever em todo o m√≥dulo pode travar o processo.

# Passo 3: Tratando o Breakpoint com Single-Step

Quando um breakpoint (INT 3) √© atingido, restauramos o `CALL` original e ativamos o **single-step mode** ‚Äî que executa apenas 1 instru√ß√£o antes de disparar outra exce√ß√£o:

```c++
case EXCEPTION_BREAKPOINT:
    if (first_break_has_occurred) {
        thread_handle = OpenThread(THREAD_ALL_ACCESS, true, debugEvent.dwThreadId);
        context.ContextFlags = CONTEXT_ALL;
        GetThreadContext(thread_handle, &context);

        context.Eip--;              // volta para o in√≠cio do CALL
        context.EFlags |= 0x100;   // ativa single-step

        SetThreadContext(thread_handle, &context);

        last_call_location = context.Eip;

        // Restaura o opcode CALL original
        WriteProcessMemory(process_handle, (void*)context.Eip, &instruction_call, 1, &bytes_written);
        FlushInstructionCache(process_handle, (LPVOID)context.Eip, 1);
    }
    first_break_has_occurred = true;
    break;
```

# Passo 4: Logando e Restaurando o Breakpoint

Quando o single-step dispara (ap√≥s o CALL executar), estamos no destino da chamada ‚Äî o EIP aponta para onde o CALL foi. Logamos e restauramos o INT 3:

```c++
case EXCEPTION_SINGLE_STEP:
    thread_handle = OpenThread(THREAD_ALL_ACCESS, true, debugEvent.dwThreadId);
    context.ContextFlags = CONTEXT_ALL;
    GetThreadContext(thread_handle, &context);

    printf("0x%08x: call 0x%08x\n", last_call_location, context.Eip);
    last_call_location = 0;

    // Restaura o breakpoint para logar futuras chamadas
    WriteProcessMemory(process_handle, (void*)last_call_location, &instruction_break, 1, &bytes_written);
    FlushInstructionCache(process_handle, (LPVOID)last_call_location, 1);
    break;
```

Com o call logger rodando, voc√™ pode executar a√ß√µes espec√≠ficas no Wesnoth e ver exatamente quais fun√ß√µes foram chamadas e em que ordem ‚Äî um mapa da execu√ß√£o do jogo em tempo real! üó∫Ô∏è

&nbsp;
