---
title: Pattern Scanner
author: attilathedud
date: 2023-12-25
category: Tool Development
layout: post
---

# Alvo

Nosso alvo é o **Wesnoth 1.14.9** e **Wesnoth 1.14.12**.

# Problema: Endereços Mudam Entre Versões

Na aula [Modificando Código do Jogo](/pages/2/03/), identificamos a instrução `sub` responsável por deduzir ouro em `0x7CCD9E` do Wesnoth 1.14.9. Quando os desenvolvedores lançam novas versões, eles recompilam o jogo — e todos os endereços mudam.

No Wesnoth 1.14.12, `0x7CCD9E` não tem mais a instrução `sub`:

![Endereço Mudou](/assets/images/7/2/pattern2.png)

A nova localização é `0x7D177E`. Se sair a 1.14.15, precisamos buscar de novo — um processo demorado.

# Solução: Opcodes Não Mudam

Embora os **endereços** mudem entre versões, os **opcodes** (bytes) de uma instrução são sempre os mesmos. Por exemplo, a instrução `sub` sempre produz o opcode `29 42 04`.

Podemos ver esses bytes no x64dbg:

![View de Opcodes](/assets/images/7/2/pattern4.png)

E confirmar no editor hexadecimal **HxD** (que exibe o arquivo exe diretamente):

```powershell
choco install hxd
```

A ideia: **varrer a memória do jogo em execução** procurando o padrão de bytes `29 42 04` — encontramos o endereço correto independente da versão!

# Construindo o Pattern Scanner

**1. Obter o handle do processo** (igual ao DLL Injector):

```c++
#include <windows.h>
#include <tlhelp32.h>

snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
// ... localizar wesnoth.exe e abrir processo
HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, true, pe32.th32ProcessID);
```

**2. Localizar o módulo principal (`wesnoth.exe`)**:

Com `CreateToolhelp32Snapshot` também podemos iterar os módulos de um processo. O módulo `wesnoth.exe` tem `modBaseAddr` (endereço base) e `modBaseSize` (tamanho):

```c++
HANDLE module_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pe32.th32ProcessID);
MODULEENTRY32 me32;
me32.dwSize = sizeof(MODULEENTRY32);
Module32First(module_snapshot, &me32);
do {
    if (wcscmp(me32.szModule, L"wesnoth.exe") == 0) {
        // me32.modBaseAddr = endereço base
        // me32.modBaseSize = tamanho
        break;
    }
} while (Module32Next(module_snapshot, &me32));
```

**3. Ler o módulo inteiro para um buffer**:

```c++
unsigned char *buffer = (unsigned char*)calloc(1, me32.modBaseSize);
DWORD bytes_read = 0;
ReadProcessMemory(process, (void*)me32.modBaseAddr, buffer, me32.modBaseSize, &bytes_read);
```

**4. Varrer o buffer procurando o padrão**:

```c++
unsigned char bytes[] = { 0x29, 0x42, 0x04 };    // opcodes da instrução sub

for (unsigned int i = 0; i < me32.modBaseSize - sizeof(bytes); i++) {
    for (int j = 0; j < sizeof(bytes); j++) {
        if (bytes[j] != buffer[i + j]) break;

        if (j + 1 == sizeof(bytes)) {
            // Encontrou! Calcula o endereço real
            printf("%x\n", i + (DWORD)me32.modBaseAddr);
        }
    }
}
```

Com o Wesnoth 1.14.12 rodando, o scanner imprime corretamente `0x7D177E`:

![Pattern Scanner Resultado](/assets/images/7/2/pattern9.png)

O mesmo scanner funciona com qualquer versão do Wesnoth automaticamente! ✅

O código completo está no [GitHub](https://github.com/GameHackingAcademy/PatternScanner/).

&nbsp;
