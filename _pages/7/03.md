---
title: Memory Scanner
author: attilathedud
date: 2023-12-25
category: Tool Development
layout: post
---

# Alvo

Nosso alvo é o **Wesnoth 1.14.9**.

# Visão Geral

O Cheat Engine é um **memory scanner** — um programa que busca e edita valores na memória de um processo. Nesta aula, vamos criar nosso próprio memory scanner que opera em valores DWORD.

![Memory Scanner](/assets/images/7/3/wesnoth.png)

# Operações do Scanner

Um memory scanner tem três operações:

| Operação | O que faz |
|---|---|
| **search** | Varre toda a memória procurando endereços com o valor dado |
| **filter** | Dos endereços encontrados, mantém apenas os que ainda têm um novo valor |
| **write** | Escreve um valor nos endereços filtrados |

Os resultados são persistidos em arquivos (`res.txt`) para passar de uma operação para a outra:

```powershell
MemoryScanner.exe search 75     # busca ouro = 75
MemoryScanner.exe filter 54     # após gastar ouro, filtra para = 54
MemoryScanner.exe write 555     # seta o endereço para 555
```

# Estrutura do Programa

O programa usa argumentos de linha de comando para escolher a operação:

```c++
char* p;
long value = strtol(argv[2], &p, 10);    // converte string para número

if (strcmp(argv[1], "search") == 0)       search(process, value);
else if (strcmp(argv[1], "filter") == 0)  filter(process, value);
else if (strcmp(argv[1], "write") == 0)   write(process, value);
```

# Função: Search

Varre toda a memória de `0x00000000` a `0x7FFFFFFF` em blocos de 2056 bytes (`0x808`):

```c++
#define size 0x00000808
unsigned char* buffer = (unsigned char*)calloc(1, size);

for (DWORD i = 0x00000000; i < 0x7FFFFFFF; i += size) {
    ReadProcessMemory(process, (void*)i, buffer, size, &bytes_read);

    for (int j = 0; j < size - 4; j += 4) {
        DWORD val = 0;
        memcpy(&val, &buffer[j], 4);
        if (val == passed_val) {
            fprintf(temp_file, "%x\n", i + j);    // guarda o endereço
        }
    }
}
```

> **Por que blocos?** A memória é um espaço virtual — nem tudo está alocado. Se tentar ler um bloco inválido, o `ReadProcessMemory` falha e o buffer fica zerado (sem falso positivo). Leitura em blocos pequenos isola as falhas.

# Função: Filter

Lê `res.txt`, verifica cada endereço e mantém apenas os que ainda têm o valor pedido:

```c++
DWORD address = 0;
while (fscanf_s(temp_file, "%x\n", &address) != EOF) {
    DWORD val = 0;
    ReadProcessMemory(process, (void*)address, &val, 4, &bytes_read);
    if (val == passed_val) {
        fprintf(temp_file_filter, "%x\n", address);    // mantém
    }
}
// depois copia res_fil.txt → res.txt e apaga res_fil.txt
```

# Função: Write

Escreve um valor em todos os endereços em `res.txt`:

```c++
DWORD address = 0;
while (fscanf_s(temp_file, "%x\n", &address) != EOF) {
    WriteProcessMemory(process, (void*)address, &passed_val, 4, &bytes_written);
}
```

Com o scanner completo, podemos reproduzir o fluxo do Cheat Engine:
1. Buscar o ouro inicial (`search 75`)
2. Gastar ouro no jogo
3. Filtrar pelo novo valor (`filter 54`)
4. Identificar o endereço único e escrever (`write 555`)

O código completo está no [GitHub](https://github.com/GameHackingAcademy/MemoryScanner/).

&nbsp;
