---
title: Debugger
author: attilathedud
date: 2023-12-25
category: Tool Development
layout: post
---

# Alvo

Nosso alvo é o **Assault Cube 1.2.0.2**.

# Visão Geral

O x64dbg permite setar breakpoints em instruções de jogos. Quando o jogo executa a instrução, a execução pausa e podemos ver todos os registradores.

Nesta aula, criaremos nosso próprio **debugger** usando a API do Windows. Vamos confirmar seu funcionamento setando um breakpoint no endereço `0x0046366C` (instrução de disparo do Assault Cube) e verificando que só dispara ao atirar.

# Como Breakpoints Funcionam

Quando queremos pausar num endereço específico, **substituímos o opcode original por `0xCC` (instrução `INT 3`)**. Quando o CPU executa o `INT 3`, o Windows gera um evento de breakpoint que nosso debugger captura.

Após capturar o evento:
1. Restauramos o opcode original
2. Corrigimos o EIP (ponteiro de instrução) para apontar de volta para o endereço correto
3. Continuamos a execução normalmente

# Passo 1: Escrevendo o INT 3

```c++
BYTE instruction_break = 0xCC;
BYTE instruction_normal = 0x8B;    // opcode original (MOV)

// ... encontrar ac_client.exe com CreateToolhelp32Snapshot ...
process_handle = OpenProcess(PROCESS_ALL_ACCESS, true, pe32.th32ProcessID);
WriteProcessMemory(process_handle, (void*)0x0046366C, &instruction_break, 1, &bytes_written);
```

# Passo 2: Loop Principal do Debugger

Baseado no [exemplo MSDN de debugger:](https://docs.microsoft.com/en-us/windows/win32/debug/creating-a-basic-debugger)

```c++
DEBUG_EVENT debugEvent = { 0 };
DWORD continueStatus = DBG_CONTINUE;

DebugActiveProcess(pid);    // anexa ao processo do jogo

for (;;) {
    if (!WaitForDebugEvent(&debugEvent, INFINITE))
        return 0;

    continueStatus = DBG_CONTINUE;

    switch (debugEvent.dwDebugEventCode) {
        case EXCEPTION_DEBUG_EVENT:
            switch (debugEvent.u.Exception.ExceptionRecord.ExceptionCode) {
                case EXCEPTION_BREAKPOINT:
                    // nosso breakpoint foi atingido!
                    break;
                default:
                    continueStatus = DBG_EXCEPTION_NOT_HANDLED;
                    break;
            }
            break;
    }

    ContinueDebugEvent(debugEvent.dwProcessId, debugEvent.dwThreadId, continueStatus);
}
```

# Passo 3: Tratando o Breakpoint

Quando nos anexamos a um processo, o Windows dispara **automaticamente** um breakpoint inicial — precisamos ignorá-lo:

```c++
bool first_break_has_occurred = false;

case EXCEPTION_BREAKPOINT:
    if (first_break_has_occurred) {
        // aqui tratamos nosso breakpoint real
    }
    first_break_has_occurred = true;    // ignora a primeira vez
    continueStatus = DBG_CONTINUE;
    break;
```

# Passo 4: Corrigindo o EIP e Restaurando o Opcode

Quando o CPU executa o `INT 3`, o **EIP** (ponteiro de instrução) já avançou 1 byte. Precisamos revertê-lo:

```c++
HANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, true, debugEvent.dwThreadId);
if (thread_handle != NULL) {
    CONTEXT context = { 0 };
    context.ContextFlags = CONTEXT_ALL;
    GetThreadContext(thread_handle, &context);

    context.Eip--;    // reverte o EIP para o endereço do nosso breakpoint

    SetThreadContext(thread_handle, &context);
    CloseHandle(thread_handle);

    // Restaura o opcode original
    WriteProcessMemory(process_handle, (void*)0x0046366C, &instruction_normal, 1, &bytes_written);
}
```

Com isso, o debugger:
- Não trava o jogo após o breakpoint ser atingido
- Informa corretamente quando o jogador dispara
- Permite visualizar todos os registradores no momento do breakpoint

![Registradores no Breakpoint](/assets/images/7/5/debug1.png)

A mesma técnica de modificar o EIP pode ser usada para modificar qualquer outro registrador no momento do breakpoint!

O código completo está no [GitHub](https://github.com/GameHackingAcademy/Debugger).

&nbsp;
