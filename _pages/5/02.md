---
title: Wallhack (Memória)
author: attilathedud
date: 2023-12-25
category: FPS
layout: post
---

# Alvo

Nesta seção, mudamos para um alvo FPS: o [Urban Terror 4.3.4](https://www.urbanterror.info/), baseado na engine Quake. Como o Wesnoth, é open source e sem anti-cheat, e roda bem em hardware de baixo desempenho.

> **Aceleração 3D:** Para rodar Urban Terror no VirtualBox, habilite a aceleração 3D nas configurações da VM. Se isso não funcionar, você pode usar outra VM (VMWare) ou outro jogo-alvo com requisitos menores.

# Identificar

Vamos criar um **wallhack** — um hack que permite ver outros jogadores através das paredes. Nosso método: modificar uma flag de renderização na memória do jogo, sem tocar nas funções gráficas.

# Entender

Em jogos 3D, o **depth testing** (teste de profundidade) determina quando um objeto deve ser visível ou oculto. Se um jogador está atrás de uma parede, o depth testing instrui o motor de renderização a não desenhá-lo.

Todo wallhack funciona desabilitando o depth testing. Nesta aula, usaremos a lógica de renderização nativa do jogo — sem precisar hookear a biblioteca gráfica (isso será feito na próxima aula).

O Urban Terror (e jogos Quake-based) renderiza todos os objetos dinâmicos (**entities**: jogadores, armas, portas) com a mesma função. Mas cada entidade tem uma estrutura de dados com um valor de **render type** — que controla como ela é desenhada. Alguns objetos (como água e vidro) desativam o depth testing. Se forçarmos todas as entidades a usar esse valor, jogadores aparecerão através das paredes.

# Configurando o Alvo

O Urban Terror tem um **console** acessível com a tecla `~`. Comandos úteis:

| Comando | Efeito |
|---|---|
| `\devmap abbey` | Carrega o mapa Abbey com cheats habilitados |
| `\g_gametype 0` | Modo deathmatch |
| `\bot_enable 1` | Habilita bots |
| `\addbot boa 1` | Adiciona um bot |
| `\reload` | Reinicia o mapa |

Use `Alt+Enter` para mudar para o modo janela.

# Localizando o Draw Entities

Explore os comandos `\r_` no console:

![Comandos de Console do Urban Terror](/assets/images/5/2/urbanterror1.png)

O comando `r_drawentities` é o mais importante. Definindo para `0`, nenhuma entidade é desenhada (inclusive nosso jogador):

![Jogador Não Sendo Desenhado](/assets/images/5/2/urbanterror2.png)

O código do jogo provavelmente é algo como:
```c++
if(r_drawentities == 1) {
    draw_entities();
}
```

Para encontrar esse código: localize o endereço de `r_drawentities` com Cheat Engine (alternando entre 0 e 1 no console), depois sete um breakpoint de acesso no x64dbg. O breakpoint disparará neste código:

![r_drawentities no Urban Terror](/assets/images/5/2/urbanterror3.png)

O valor é carregado em **ecx** e testado. Se for 0, pula o `call 0x52F71F`. Esse call é responsável por desenhar as entidades — confirmado NOPando-o (ao NOPar, nenhuma entidade aparece).

# Entidades e Renderização

Entrando no `call 0x52F71F`:

![Código de Renderização de Entidades](/assets/images/5/2/urbanterror4.png)

Valores são carregados em registradores e comparados. Os registradores são baseados no endereço em **ebx**. Em `0x52D2FD`, **ebx** contém a entidade atual sendo renderizada.

Sete um breakpoint em `0x52D2FD` e observe o dump de **ebx** — você verá um bloco contínuo de dados que representa a estrutura da entidade:

![Estrutura de Entidade Urban Terror](/assets/images/5/2/urbanterror5.png)

# Revertendo a Estrutura da Entidade

Precisamos encontrar qual campo da estrutura controla o render type. Use o painel **Watch** do x64dbg para observar **[ebx]**, **[ebx+4]** até **[ebx+2C]** simultaneamente:

![Painel Watch](/assets/images/5/2/urbanterror8.png)

Carregue o mapa *Abbey* (que tem uma fonte com água). Observe o Watch enquanto entidades diferentes são renderizadas:

![Painel Watch](/assets/images/5/2/urbanterror10.png)
![Painel Watch](/assets/images/5/2/urbanterror11.png)

Observando os padrões:
- `[ebx]` → sempre 0 (descarte)
- `[ebx+4]` → alterna entre `0xD`, `0x40`, `0x82`, `0x83` (candidato!)
- `[ebx+8]` → único para cada entidade (descarte — parece ser um ID)

`[ebx+4]` é nosso candidato para render type.

# Modificando o Render Type

Criamos uma DLL que hooka `0x52D2FD` e define `[ebx+4]` para cada entidade. Testando os valores:

```c++
__declspec(naked) void codecave() {
    __asm {
        pushad
        mov dword ptr ds:[ebx+4], 0xD    // teste: valor 0xD
        popad
        mov dword ptr ds:[0x102AE98], ebx
        jmp ret_address
    }
}
```

- `0x83` → sem mudanças visíveis
- `0x40` → sombras ligeiramente diferentes  
- **`0xD` → modelo do jogador fica transparente!** ✅

![Depth Testing Desabilitado](/assets/images/5/2/urbanterror13.png)

Mude para terceira pessoa (`cg_thirdperson`) e adicione bots — você os verá através das paredes:

![Depth Testing Desabilitado](/assets/images/5/2/urbanterror14.png)

Outros objetos (escadas, armas) também aparecem através das paredes, pois estamos desabilitando o depth testing para todas as entidades. Para melhorar: identifique a estrutura do jogador e restaure o depth testing para seu próprio modelo (evitando que a visão em primeira pessoa fique corrompida).

O código completo está no [GitHub](https://github.com/GameHackingAcademy/UrbanTerror_MemoryWallhack/).

&nbsp;
