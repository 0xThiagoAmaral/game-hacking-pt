---
title: Aimbot
author: attilathedud
date: 2023-12-25
category: FPS
layout: post
---

# Alvo

Nosso alvo é o **Assault Cube 1.2.0.2**.

# Identificar

Vamos criar um **aimbot** — um hack que mira automaticamente em outros jogadores.

# Entender

O fundamento de um aimbot é **trigonometria**. Dado um jogador e um inimigo no mundo 3D, precisamos calcular o ângulo que nosso jogador precisa ter para olhar diretamente para o inimigo.

Veja a cena a seguir:

![Gameplay do Assault Cube](/assets/images/5/6/cube1.png)

Para simplificar: vendo de cima (perspectiva top-down), eliminamos o eixo Z e ficamos com um gráfico 2D:

![Representação 2D](/assets/images/5/6/cube3.png)

Para mirar no inimigo, precisamos calcular o ângulo **θ** (theta). Com as posições do jogador e do inimigo, formamos um triângulo retângulo e usamos o **arcotangente**:

```c++
θ = arctan(Δy / Δx)
```

Em C++, usamos `atan2f` (que lida corretamente com ângulos negativos):

```c++
float azimuth_xy = atan2f(abspos_y, abspos_x);    // retorna radianos
float yaw = azimuth_xy * (180.0f / M_PI);          // converte para graus
```

Para mirar para **cima e para baixo** (eixo Z), fazemos o mesmo cálculo para Z vs Y.

# Localizando os Inimigos

Configure um jogo com 8 bots em modo idle (`idlebots 1` no console). Na aula anterior, localizamos a função de nametag. Dentro dela, o jogo itera pela lista de jogadores. Seguindo o código, encontramos:

- `[0x50F500]` = número atual de jogadores no jogo
- `[0x50F4F8]` = base da lista de jogadores; cada jogador em `[[0x50F4F8] + 4*i]`

# Localizando Nosso Jogador

O Assault Cube tem o comando `dbgpos 1` + `showstats 1` que exibe posição e ângulos na tela:

![dbgpos](/assets/images/5/6/cube15.png)

Os ângulos são **yaw** (esquerda/direita) e **pitch** (cima/baixo) em graus. Busque o yaw no Cheat Engine, sete um breakpoint de acesso — você encontrará que o ponteiro base do jogador está em `[0x509B74]`.

# Revertendo a Estrutura do Jogador

Visualizando a memória em float no x64dbg (botão direito → Float), os valores de X, Y, Z, yaw e pitch ficam evidentes:

![Estrutura do Jogador](/assets/images/5/6/cube20.png)

```c++
struct Player {
    char unknown1[4];
    float x;
    float y;
    float z;
    char unknown2[0x30];    // padding até o yaw
    float yaw;
    float pitch;
    char unknown3[0x2f0];   // padding até o campo dead
    int dead;               // 0 = vivo, 1 = morto
};
```

# Fazendo o Jogador Girar (Verificação)

Antes do aimbot, vamos confirmar que acertamos a estrutura fazendo o jogador girar:

```c++
DWORD* player_offset = (DWORD*)(0x509B74);
player = (Player*)(*player_offset);
player->yaw++;    // gira o jogador continuamente
```

Compile e injete — seu personagem vai girar em círculos. ✅

# Mirando Esquerda/Direita

```c++
// Posição relativa (como se o jogador estivesse na origem)
float abspos_x = enemy->x - player->x;
float abspos_y = enemy->y - player->y;

// Calcular o ângulo em graus
float azimuth_xy = atan2f(abspos_y, abspos_x);
float yaw = (float)(azimuth_xy * (180.0 / M_PI));

// Assault Cube começa com yaw=90°, então compensamos
player->yaw = yaw + 90;
```

# Mirando Cima/Baixo

```c++
float abspos_z = enemy->z - player->z;

// Garantir que abspos_y seja positivo e grande o suficiente
if (abspos_y < 0) abspos_y *= -1;
if (abspos_y < 5) {
    if (abspos_x < 0) abspos_x *= -1;
    abspos_y = abspos_x;
}

float azimuth_z = atan2f(abspos_z, abspos_y);
player->pitch = (float)(azimuth_z * (180.0 / M_PI));
```

> A verificação de `abspos_y < 5` evita que quando estamos muito perto do inimigo o pitch fique apontando para o céu (arctan(3/1) = 75°!).

# Múltiplos Inimigos

Para múltiplos inimigos, iteramos a lista e escolhemos o **mais próximo** via distância euclidiana:

```c++
float euclidean_distance(float x, float y) {
    return sqrtf((x * x) + (y * y));
}

int* current_players = (int*)(0x50F500);
float closest_player = -1.0f;
float closest_yaw = 0.0f, closest_pitch = 0.0f;

for (int i = 0; i < *current_players; i++) {
    DWORD* enemy_list = (DWORD*)(0x50F4F8);
    DWORD* enemy_offset = (DWORD*)(*enemy_list + (i*4));
    Player* enemy = (Player*)(*enemy_offset);

    if (enemy == NULL || enemy->dead) continue;

    float dist = euclidean_distance(abspos_x, abspos_y);
    if (closest_player == -1.0f || dist < closest_player) {
        closest_player = dist;
        closest_yaw = yaw + 90;
        closest_pitch = pitch;
    }
}

player->yaw = closest_yaw;
player->pitch = closest_pitch;
```

Resultado final com múltiplos inimigos:

<video controls autoplay loop>
  <source src="/assets/images/5/6/cube.mp4" />
</video>

O código completo está no [GitHub](https://github.com/GameHackingAcademy/AssaultCube_Aimbot/).

&nbsp;
