---
title: No Recoil
author: attilathedud
date: 2023-12-25
category: FPS
layout: post
---

# Alvo

Nosso alvo é o **Assault Cube 1.2.0.2**.

# Identificar

Vamos criar um hack de **no recoil** — que elimina o recuo da arma ao disparar. O recuo é o movimento automático da mira para cima ao atirar.

<video controls autoplay loop>
  <source src="/assets/images/5/7/cube.mp4" />
</video>

# Entender

Quando disparamos, jogos aplicam vários efeitos:
- **Recoil** (recuo: mira sobe)
- **Spread** (dispersão: aleatório)
- **Pushback** (empurrão: jogador é empurrado)

O recuo funciona somando um valor ao **pitch** (ângulo vertical) do jogador. Como ângulos são floats, as instruções são:

```c++
fld recoil_amount                       ; carrega valor de recuo em st(0)
fadd st(0), players_pitch               ; soma ao pitch atual
fstp players_pitch, st(0)              ; salva resultado no pitch
```

Se NOParmos a instrução `fstp` (que salva o resultado), o recuo não é aplicado. Mas NOPar `fstp` diretamente deixaria um valor extra na pilha FPU, corrompendo o jogo. A solução: substituir o `fstp` por `fstp st0` — que descarta o valor da pilha sem usá-lo.

# Localizando a Função de Disparo

Busque o endereço de munição com Cheat Engine. Sete um breakpoint de escrita no x64dbg e atire:

![Função de Recuo](/assets/images/5/7/cube1.png)

Essa instrução é responsável por diminuir a munição. Suba um nível (execute till return / step over):

![Função de Recuo](/assets/images/5/7/cube2.png)

Verifique o contexto: o breakpoint em `call edx` dispara continuamente (não só ao atirar), então estamos alto demais. Entre na função e siga o código — você verá um `jmp` que só é tomado ao atirar:

![Função de Recuo](/assets/images/5/7/cube4.png)

Mude o salto condicional para `jmp` para confirmar: o jogador vai atirar continuamente. Siga esse jmp para o início do código de disparo em `0x46366C`.

# Localizando o Recuo

Agora que temos o início do código de disparo, setamos um breakpoint lá, atiramos **um tiro** e, quando o breakpoint disparar, setamos outro breakpoint de escrita no **endereço do pitch** do jogador.

Ao continuar, o breakpoint do pitch dispara no código de recuo:

![Função de Recuo](/assets/images/5/7/cube6.png)

A instrução `fstp dword ptr ds:[ebx+0x44]` escreve o valor de recuo no pitch. Aqui:
- `ebx+0x44` = endereço do pitch do jogador
- `st0` = o novo valor de pitch calculado

# Eliminando o Recuo

Para evitar que o recuo seja aplicado **sem corromper a pilha FPU**, substituímos o `fstp [endereço]` por `fstp st0` — isso descarta o valor sem salvá-lo em memória:

![Função de Recuo](/assets/images/5/7/cube7.png)

Com essa mudança, o recuo desaparece completamente.

# Criando a DLL

Igual ao hack do mapa, apenas escrevemos os bytes no endereço:

```c++
#include <Windows.h>

unsigned char new_bytes[3] = { 0xDD, 0xD8, 0x90 };    // fstp st0 + NOP

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    DWORD old_protect;
    unsigned char* hook_location = (unsigned char*)0x45BAAD;

    if (fdwReason == DLL_PROCESS_ATTACH) {
        VirtualProtect((void*)hook_location, 3, PAGE_EXECUTE_READWRITE, &old_protect);
        for (int i = 0; i < sizeof(new_bytes); i++) {
            *(hook_location + i) = new_bytes[i];
        }
    }

    return true;
}
```

O código completo está no [GitHub](https://github.com/GameHackingAcademy/AssaultCube_NoRecoil).

&nbsp;
