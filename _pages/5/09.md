---
title: ESP
author: attilathedud
date: 2023-12-25
category: FPS
layout: post
---

# Alvo

Nosso alvo é o **Assault Cube 1.2.0.2**.

# Identificar

Vamos criar um **ESP** (Extra Sensory Perception) — um hack que exibe o nome dos jogadores acima de suas cabeças, mesmo através das paredes.

# Entender

No aimbot, calculamos o ângulo necessário para mirar num inimigo e **setamos** esse ângulo. No ESP, calculamos a mesma diferença de ângulos para descobrir onde o inimigo aparece na tela 2D — e exibimos texto nesse ponto.

> **Metáfora:** É como projeta uma sombra do mundo 3D num papel 2D. A posição da sombra corresponde à posição na tela.

# Viewports

Quando nos movemos no mundo, nossa câmera (viewport) se move junto. O inimigo permanece na mesma posição 3D, mas aparece num local diferente da tela 2D dependendo de onde estamos olhando.

# World to Screen (Convertendo Mundo para Tela)

Para o eixo X (esquerda/direita), a fórmula básica é:

```
screen_x = centro_da_tela + (diferença_de_yaw * fator_de_escala)
```

**Calculando a diferença de yaw:**

```c++
// Calculamos o yaw ideal para mirar no inimigo (igual ao aimbot)
float yaw = atan2f(abspos_y, abspos_x) * (180.0f / M_PI) + 90;

// A diferença entre nosso yaw atual e o yaw ideal
float yaw_dif = player->yaw - yaw;
```

Para encontrar o **fator de escala (F)**, usamos três cenários (olhando diretamente, inimigo à esquerda, inimigo à direita) e algebra básica:

- Centro da tela virtual do Assault Cube = 1200 (não 512, pois o jogo usa tela virtual de 2400×1800)
- F calculado ≈ **-30**

```c++
screen_x = 1200 + (yaw_dif * -30);
```

Para o eixo Y (cima/baixo), o processo é idêntico mas com pitch:

```c++
float pitch = atan2f(abspos_z, abspos_y) * (180.0f / M_PI);
float pitch_dif = player->pitch - pitch;
screen_y = 900 + (pitch_dif * 25);    // fator Y ≈ 25
```

**Corrigindo valores extremos** (quando yaw_dif ultrapassa 180°):

```c++
if (yaw_dif > 180)  yaw_dif -= 360;
if (yaw_dif < -180) yaw_dif += 360;
```

# Localizando a Função de Impressão de Texto

O comando `showspeed 1` exibe texto no centro da tela. Buscamos esse texto no x64dbg via *Memory Map → Find Pattern*. Com o endereço encontrado, procuramos referências (*Find references*) e chegamos ao `call 0x419880` — a função de impressão.

Os parâmetros são: Y primeiro (push), depois X (push), depois texto em **ecx**.

# Code Cave de Impressão

Hookamos o `call` de impressão do texto de velocidade para imprimir nosso ESP:

```c++
DWORD ret_address = 0x0040BE83;
DWORD text_address = 0x419880;
const char* empty_text = "";

__declspec(naked) void codecave() {
    __asm {
        mov ecx, empty_text
        call text_address
        pushad
    }

    // Loop para imprimir todos os inimigos
    current_players = (int*)(0x50F500);
    for (int i = 1; i < *current_players; i++) {
        DWORD x = x_values[i];
        DWORD y = y_values[i];
        const char* text = names[i];

        if (x > 2400 || x < 0 || y < 0 || y > 1800) {
            text = "";    // fora da tela — não exibe
        }
        x += 200;    // pequena correção de offset

        __asm {
            mov ecx, text
            push y
            push x
            call text_address
            add esp, 8    // balancear a pilha
        }
    }

    __asm {
        popad
        jmp ret_address
    }
}
```

# Adicionando o Nome do Inimigo à Estrutura

Visualizando a memória após o yaw, o nome do jogador aparece alguns bytes depois. Adicionamos à estrutura:

```c++
struct Player {
    char unknown1[4];
    float x;
    float y;
    float z;
    char unknown2[0x30];
    float yaw;
    float pitch;
    char unknown3[0x1DD];    // padding até o nome
    char name[16];           // nome tem no máximo 16 caracteres
};
```

No loop, atribuímos o nome:
```c++
names[i] = enemy->name;
```

Resultado final — nomes dos inimigos aparecem acima das cabeças, mesmo através das paredes:

<video controls autoplay loop>
  <source src="/assets/images/5/9/cube.mp4" />
</video>

O código completo está no [GitHub](https://github.com/GameHackingAcademy/AssaultCube_ESP/).

&nbsp;
