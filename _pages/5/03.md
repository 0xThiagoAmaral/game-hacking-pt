---
title: Wallhack (OpenGL)
author: attilathedud
date: 2023-12-25
category: FPS
layout: post
---

# Alvo

Nosso alvo é o **Urban Terror 4.3.4**.

# Visão Geral

A maioria dos jogos usa **bibliotecas gráficas externas** para renderizar. As duas mais populares são **DirectX** (exclusiva Windows, jogos Microsoft/Xbox) e **OpenGL** (multiplataforma, jogos Linux/Mac e muitos jogos mais antigos). Em 2026, a maioria dos jogos modernos usa DirectX 12 ou Vulkan, mas Urban Terror usa OpenGL — tornando-o ideal para aprendizado.

Essas bibliotecas são carregadas dinamicamente pelo jogo. O jogo chama funções como `glDrawElements` para desenhar objetos na tela.

# Identificar

Vamos criar um wallhack **hookando a biblioteca gráfica** e modificando sua lógica para exibir entidades através das paredes — sem modificar diretamente a memória do jogo.

# Entender

Cada biblioteca gráfica tem funções diferentes de renderização. Nosso objetivo:
1. Identificar qual biblioteca o jogo usa
2. Encontrar a função de renderização usada pelo jogo
3. Hookear essa função e desabilitar o depth testing via código

# Localizando a Biblioteca

Na aba *Symbols* do x64dbg (com o Urban Terror anexado), vemos `opengl32.dll` carregado no processo. O jogo usa **OpenGL**.

![Símbolos do Urban Terror](/assets/images/5/3/urbanterror1.png)

# Localizando a Função de Desenho

OpenGL tem várias funções de renderização. Para jogos mais modernos, `glDrawElements` é a mais comum. Verificamos:

1. Na aba *Symbols*, localize `glDrawElements` e dê duplo-clique para ver a função:

![glDrawElements no Urban Terror](/assets/images/5/3/urbanterror3.png)

2. Sete um breakpoint em `glDrawElements` e inicie um jogo — ele vai disparar continuamente (indicando que é usado para renderizar)

3. Para confirmar, substitua a primeira instrução por `ret` — o resultado é que nada é renderizado na tela:

![glDrawElements Desabilitado](/assets/images/5/3/urbanterror5.png)

# Hookando glDrawElements

Como o OpenGL é carregado dinamicamente, não podemos usar um endereço estático. A estratégia:

1. Criar uma thread que aguarda o OpenGL ser carregado
2. Usar `GetModuleHandle` para obter o endereço base do OpenGL
3. Usar `GetProcAddress` para encontrar `glDrawElements` dentro do módulo

```c++
HMODULE openGLHandle = NULL;

void injected_thread() {
    while (true) {
        if (openGLHandle == NULL) {
            openGLHandle = GetModuleHandle(L"opengl32.dll");
        }

        if (openGLHandle != NULL) {
            unsigned char* hook_location = (unsigned char*)GetProcAddress(openGLHandle, "glDrawElements");
            hook_location += 0x16;    // offset até a instrução que queremos hookear

            VirtualProtect((void*)hook_location, 5, PAGE_EXECUTE_READWRITE, &old_protect);
            *hook_location = 0xE9;
            *(DWORD*)(hook_location + 1) = (DWORD)&codecave - ((DWORD)hook_location + 5);

            ret_address = (DWORD)(hook_location + 0x6);    // calculado dinamicamente
        }

        Sleep(1);
    }
}
```

# Ponteiros de Função

Para chamar `glDepthFunc` de dentro da nossa cave (sem hookear ela), usamos um **ponteiro de função** — um ponteiro que aponta para o endereço de uma função e permite chamá-la:

A definição do `glDepthFunc`:
```c++
void glDepthFunc(GLenum func);    // GLenum = unsigned int
```

Declarando o ponteiro de função:
```c++
void (*glDepthFunc)(unsigned int) = NULL;
```

Assignando via `GetProcAddress`:
```c++
glDepthFunc = (void(__cdecl *)(unsigned int))GetProcAddress(openGLHandle, "glDepthFunc");
```

> **Convenções de chamada:** Visual Studio usa `__cdecl` por padrão, mas o OpenGL usa `__stdcall` (equivalente ao `WINAPI/APIENTRY` da Microsoft). Precisamos especificar `__stdcall` no ponteiro:

```c++
void (__stdcall *glDepthFunc)(unsigned int) = NULL;
glDepthFunc = (void(__stdcall*)(unsigned int))GetProcAddress(openGLHandle, "glDepthFunc");
```

# Code Cave do glDrawElements

Nossa cave vai chamar `glDepthFunc(GL_ALWAYS = 0x207)` para desabilitar o depth testing antes de cada draw call:

```c++
__declspec(naked) void codecave() {
    __asm { pushad }

    (*glDepthFunc)(0x207);    // desabilita depth testing para esta draw call

    __asm {
        popad
        mov esi, dword ptr ds:[esi+0xA18]    // instrução original
        jmp ret_address
    }
}
```

# Filtrando pelo Parâmetro Count

Com esse hack, **tudo** aparece através das paredes — inclusive paredes e escadas:

![Wallhack Urban Terror](/assets/images/5/3/urbanterror9.png)

A função `glDrawElements` tem o parâmetro `count` (número de vértices do elemento). Jogadores têm muitos vértices (modelo detalhado), enquanto paredes têm poucos. Podemos filtrar usando o `count`:

```c++
DWORD count = 0;
__asm {
    pushad
    mov eax, dword ptr ds:[esp + 0x10]    // count está em esp+0x10 após pushad
    mov count, eax
    popad
    pushad
}

if (count > 500) {
    (*glDepthFunc)(0x207);    // GL_ALWAYS — sempre desenha
}
else {
    (*glDepthFunc)(0x203);    // GL_LEQUAL — comportamento normal
}
```

Resultado mais limpo: apenas elementos grandes (jogadores, armas) aparecem através das paredes:

![Wallhack com Filtragem de Count](/assets/images/5/3/urbanterror14.png)

# Clipping Planes

Os modelos de jogadores ainda ficam invisíveis, pois são desenhados primeiro e sobrescritos pelo nível. Usamos `glDepthRange(0,0)` para forçar todos os objetos no mesmo plano visual:

```c++
void (__stdcall* glDepthRange)(double, double) = NULL;
glDepthRange = (void(__stdcall*)(double, double))GetProcAddress(openGLHandle, "glDepthRange");

if (count > 500) {
    (*glDepthRange)(0.0, 0.0);    // força plano único → jogadores aparecem por cima
    (*glDepthFunc)(0x207);
}
else {
    (*glDepthRange)(0.0, 1.0);    // restaura comportamento normal
    (*glDepthFunc)(0x203);
}
```

Resultado final — modelos de jogadores visíveis através das paredes:

![Wallhack Final](/assets/images/5/3/urbanterror16.png)

O código completo está no [GitHub](https://github.com/GameHackingAcademy/UrbanTerror_OpenGLWallhack/).

&nbsp;
