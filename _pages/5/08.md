---
title: Radar Hack
author: attilathedud
date: 2023-12-25
category: FPS
layout: post
---

# Alvo

Nosso alvo √© o **Assault Cube 1.2.0.2**.

# Identificar

Vamos criar um **radar hack** ‚Äî um hack que exibe todos os jogadores no radar, incluindo inimigos que normalmente seriam invis√≠veis.

![Radar Hack](/assets/images/5/8/radar1.png)

# Entender

Em jogos FPS com times, o radar normalmente exibe apenas os companheiros de equipe. O c√≥digo respons√°vel provavelmente funciona assim:

```c++
void draw_radar() {
    for(int i = 0; i < max_players; i++) {
        if(player_list[i]->team == current_player->team) {
            // desenha no radar
        }
    }
}
```

Se localizarmos essa condi√ß√£o e a removermos, **todos os jogadores** aparecer√£o no radar.

# Localizando o Time do Jogador

Precisamos primeiro encontrar o campo **team** na estrutura do jogador. Duas abordagens:

1. **Cheat Engine** ‚Äî varredura de *Unknown value*, alterne entre times, filtre por *Changed value*
2. **x64dbg** ‚Äî observe a mem√≥ria da estrutura do jogador, alterne de time, note qual byte muda

O campo de time alterna entre 0 e 1. Fica pr√≥ximo ao campo `dead` que identificamos antes.

# Localizando o C√≥digo do Radar

Com o endere√ßo do campo de time identificado, setamos um breakpoint de **acesso** nele. V√°rios trechos de c√≥digo v√£o disparar ‚Äî precisamos encontrar o respons√°vel pelo radar.

Para identificar o correto, procuramos um trecho que:
- Tem uma compara√ß√£o (`cmp` ou `test`) seguida de salto condicional (`jne`, `je`)
- Tem opera√ß√µes de ponto flutuante (`fld`, `fstp`) para posicionar o √≠cone no radar
- Chama outras fun√ß√µes ou tem bastante c√≥digo

O Assault Cube tem v√°rios trechos que acessam o campo de time. Analisando cada um:

**Pop 1** ‚Äî tem uma compara√ß√£o, mas NOPar o `jne` n√£o muda nada:

![Radar Hack](/assets/images/5/8/radar2.png)

Seguindo o `call` ‚Äî vemos uma string de "voice chat", indicando que √© c√≥digo de comunica√ß√£o no radar:

![Radar Hack](/assets/images/5/8/radar3.png)

**Pop 2** ‚Äî compara com valor est√°tico (CLA team = 0):

![Radar Hack](/assets/images/5/8/radar4.png)

**Pop 3** ‚Äî compara via `test cl, 1` (RSVF team = 1):

![Radar Hack](/assets/images/5/8/radar5.png)

Esses dois √∫ltimos pops usam valores est√°ticos, n√£o o valor da estrutura do jogador ‚Äî ent√£o n√£o √© o c√≥digo do radar.

**Pop 4** ‚Äî compara o time do jogador atual com **eax** (time de outro jogador):

![Radar Hack](/assets/images/5/8/radar6.png)

Tem `cmp` din√¢mico + opera√ß√µes de float. NOPando o `jne` em `0x409FB3`:

![Radar Hack](/assets/images/5/8/radar7.png)

Todos os jogadores aparecem no radar! üó∫Ô∏è Encontramos o c√≥digo correto.

# Modificando o C√≥digo

Como precisamos apenas NOPar 6 bytes (o tamanho do `jne`), usamos o mesmo padr√£o do hack de No Recoil:

```c++
#include <Windows.h>

unsigned char new_bytes[] = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 };    // 6 NOPs

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    DWORD old_protect;
    unsigned char* hook_location = (unsigned char*)0x409FB3;

    if (fdwReason == DLL_PROCESS_ATTACH) {
        VirtualProtect((void*)hook_location, 6, PAGE_EXECUTE_READWRITE, &old_protect);
        for (int i = 0; i < sizeof(new_bytes); i++) {
            *(hook_location + i) = new_bytes[i];
        }
    }

    return true;
}
```

Injete a DLL ‚Äî o radar passa a mostrar inimigos e aliados de todos os times.

&nbsp;
