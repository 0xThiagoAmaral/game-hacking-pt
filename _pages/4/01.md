---
title: Stathack
author: attilathedud
date: 2023-12-25
category: RTS
layout: post
---

# Alvo

Nosso alvo nesta aula é o **Wesnoth 1.14.9**.

# Identificar

Vamos criar um **stathack** — um tipo de hack que exibe informações sobre outros jogadores na tela, como o ouro ou o número de unidades deles. Nosso stathack vai mostrar o ouro do **segundo jogador**.

# Entender

Para criar o stathack, precisamos fazer duas coisas:

1. Encontrar o endereço do ouro do segundo jogador
2. Imprimir esse valor na tela do jogo

Já cobrimos as técnicas para ambas as etapas nas aulas anteriores.

# Ouro do Segundo Jogador

Na aula de [Fundamentos de Jogos](/pages/1/02/), vimos que jogos frequentemente guardam dados similares em **arrays** (listas). Usando isso como modelo, podemos tentar localizar o ouro do segundo jogador.

Sabemos da aula [Derrotando a DMA](/pages/2/09/) que o Wesnoth aloca as classes de jogadores dinamicamente a partir de um ponteiro base. Para descobrir se existe um array de jogadores, vamos observar o código em detalhe.

Crie um jogo local com dois jogadores com renda (Income). Jogue um turno de cada e então anexe o x64dbg. Sete um breakpoint no `call` em `0x9B4CE3` (o mesmo que identificamos antes) e termine o segundo turno do jogador 1:

![Breakpoint de Renda](/assets/images/4/1/wesnoth1.png)

O valor do registrador **ebx** indica que essa função é chamada para **cada jogador** a cada turno. E o **ecx** contém o ponteiro base do jogo — o mesmo para todos. Isso confirma que existe um **array de classes de jogadores**.

Agora precisamos saber o **tamanho de cada jogador** no array (para calcular o offset até o segundo). Entre na função e siga o código. Você verá uma instrução **imul** (multiplicação com sinal):

![Instrução imul](/assets/images/4/1/wesnoth2.png)

Para o primeiro jogador, **edx** = 0. Para o segundo, **edx** = 1. O jogo usa **edx** como índice e multiplica por `0x270` — o tamanho de um jogador no array. Esse resultado é somado ao endereço base do jogador para obter o endereço correto:

![Offsetando o Jogador](/assets/images/4/1/wesnoth3.png)

Então:
- Ouro do **primeiro** jogador: `[[0x017EED18] + 0xA90] + 4`
- Ouro do **segundo** jogador: `[[0x017EED18] + 0xA90] + 4 + 0x270` = `+ 0x274`

Verificação no Cheat Engine:

![Verificando o Endereço do Ouro do Segundo Jogador](/assets/images/4/1/wesnoth4.png)

Em C++:
```c++
player_base = (DWORD*)0x017EED18;
game_base = (DWORD*)(*player_base + 0xA90);
gold = (DWORD*)(*game_base + 0x274);    // 0x274 em vez de 4 = segundo jogador
```

# Imprimindo o Valor

Na aula anterior, vimos que o texto exibido pelo *Terrain Description* é acessado via **edx**. Vamos usar a mesma code cave para substituir aquele texto pelo ouro do segundo jogador.

Esqueleto da cave (chamada cada vez que *Terrain Description* é invocado):

```c++
DWORD ori_call_address = 0x5E9630;
DWORD ret_address = 0x5ED12E;

__declspec(naked) void codecave() {
    __asm { pushad }

    // novo código aqui

    __asm {
        popad
        call ori_call_address
        jmp ret_address
    }
}
```

Dentro da cave, recuperamos o ouro do segundo jogador:

```c++
player_base = (DWORD*)0x017EED18;
game_base = (DWORD*)(*player_base + 0xA90);
gold = (DWORD*)(*game_base + 0x274);
```

Para exibir o número como texto, convertemos usando `sprintf_s`:

```c++
#include <stdio.h>

char gold_byte_array[4] = { 0 };
sprintf_s(gold_byte_array, 4, "%d", *gold);
```

Isso converte o número inteiro para uma string de caracteres. Por exemplo: 225 vira `['2','2','5']`.

Depois restauramos e re-salvamos os registradores (porque `sprintf_s` modifica alguns) e movemos os bytes do texto para a memória do jogo:

```c++
__asm {
    popad
    pushad
    mov eax, dword ptr ds:[edx]
    mov bl, gold_byte_array[0]
    mov byte ptr ds:[eax], bl
    mov bl, gold_byte_array[1]
    mov byte ptr ds:[eax + 1], bl
    mov bl, gold_byte_array[2]
    mov byte ptr ds:[eax + 2], bl
}
```

Por fim, redirecionamos a função de impressão no `DllMain`:

```c++
DWORD old_protect;
unsigned char* hook_location = (unsigned char*)0x5ED129;

if (fdwReason == DLL_PROCESS_ATTACH) {
    VirtualProtect((void*)hook_location, 5, PAGE_EXECUTE_READWRITE, &old_protect);
    *hook_location = 0xE9;
    *(DWORD*)(hook_location + 1) = (DWORD)&codecave - ((DWORD)hook_location + 5);
}
```

Injete a DLL (idêntico às aulas anteriores) e, dentro de um jogo, abra o *Terrain Description* em qualquer tile. O ouro do segundo jogador aparecerá no texto:

![Stathack](/assets/images/4/1/wesnoth6.png)

O código completo está no [GitHub](https://github.com/GameHackingAcademy/Wesnoth_Stathack/).

&nbsp;
