---
title: Macro Bot
author: attilathedud
date: 2023-12-25
category: RTS
layout: post
---

> *Nota: A vers√£o do Wyrmsun dispon√≠vel na Steam n√£o √© mais a 5.0.1. Voc√™ pode baixar o bin√°rio da vers√£o 5.0.1 no [GitHub](https://github.com/Andrettin/Wyrmsun/releases/tag/v5.0.1).*

# Alvo

Nesta aula, mudamos de alvo para o jogo [Wyrmsun](https://store.steampowered.com/app/370070/Wyrmsun), vers√£o 5.0.1. O motivo: o Wesnoth n√£o suporta mec√¢nicas em tempo real (como construir unidades automatically) que um macro bot precisa. O Wyrmsun √© gratuito e funciona de forma similar a outros jogos RTS cl√°ssicos como StarCraft, WarCraft ou Command & Conquer.

# Identificar

Um **macro bot** monitora nossos recursos e **constr√≥i automaticamente unidades trabalhadoras**. Nosso bot vai detectar quando o dinheiro superar 3000 e recrutar uma unidade de trabalhador automaticamente na estrutura selecionada.

<video controls autoplay loop>
  <source src="/assets/images/4/3/macro1.mp4" />
</video>

# Entender

Para criar um macro bot, precisamos entender como jogos RTS gerenciam a cria√ß√£o de unidades. Tipicamente, o c√≥digo pode parecer com:

```c++
recruit_unit(unit_type) {
  memory = initialize_memory(sizeof(unit))
  unit = create_unit(unit_type, memory)
  player->decrease_money()
  player->add_unit(unit)
  player->increase_population_counter()
}
```

Precisamos encontrar essa fun√ß√£o e **cham√°-la n√≥s mesmos**. Dois m√©todos para localiz√°-la:

- Se o dinheiro diminui instantaneamente ao recrutar ‚Üí localize o dinheiro e sete um breakpoint de escrita
- Se a popula√ß√£o aumenta instantaneamente ao recrutar ‚Üí localize a popula√ß√£o e sete um breakpoint de escrita

Wyrmsun carrega c√≥digo dinamicamente ‚Äî os endere√ßos que voc√™ v√™ aqui ser√£o diferentes quando voc√™ seguir o tutorial. As instru√ß√µes e m√©todos, por√©m, n√£o mudam.

# Localizando a Fun√ß√£o de Recrutamento

No Wyrmsun, o dinheiro diminui instantaneamente. Use o m√©todo do [Memory Hack](/pages/1/05/) para encontrar seu endere√ßo de dinheiro. Em seguida, anexe o x64dbg e sete um breakpoint de escrita no endere√ßo. Recrute um trabalhador ‚Äî o breakpoint vai disparar.

Use *Execute till return / Step Over* para subir v√°rios n√≠veis de c√≥digo at√© ver algo parecido com:

![Fun√ß√£o de Recrutar Unidade](/assets/images/4/3/macro2.png)

Suba mais um n√≠vel para ver a fun√ß√£o que chama o recrutamento:

![Fun√ß√£o de Recrutar Unidade](/assets/images/4/3/macro3.png)

Essa fun√ß√£o tem v√°rios `call`s similares com um √∫nico par√¢metro. Se voc√™ setar um breakpoint no `call 0xF42CF7` e testar v√°rias a√ß√µes no jogo (mover unidades, atacar, construir), perceber√° que esse `call` √© chamado **s√≥ quando uma unidade √© recrutada**.

Verifique fazendo NOP nas tr√™s instru√ß√µes abaixo. Se o recrutamento parar de funcionar, voc√™ encontrou a fun√ß√£o certa:

```c++
push ecx
mov ecx, esi
call 0xF42CF7
```

# Revertendo a Estrutura de Dados

A fun√ß√£o de recrutamento recebe dois par√¢metros poss√≠veis: o valor em **ecx** (pushado) e o valor em **esi** (movido para **ecx**). Testando:

- Substituir `push ecx` por `push eax` ‚Üí jogo trava (o push ecx √© essencial)
- NOPear `mov ecx, esi` ‚Üí jogo funciona normalmente (n√£o √© necess√°rio)

Ent√£o s√≥ precisamos reverter o valor de **ecx**. Sete um breakpoint em `push ecx` e recrute um trabalhador. Ao disparar, siga o valor de **ecx** no dump. O conte√∫do parece ser uma tabela de ponteiros (valores repetidos). Siga o primeiro ponteiro (`0xf01db710`) e voc√™ encontrar√° a palavra *worker* ‚Äî a estrutura do tipo de unidade:

![Fun√ß√£o de Recrutar Unidade](/assets/images/4/3/macro5.png)

Recrute uma unidade diferente (infantaria). A mesma √°rea de mem√≥ria em `0x10b71df0` mostra *infantry* e um n√∫mero diferente (`0x41` vs `0x2c`). Esse n√∫mero provavelmente √© o ID interno da unidade.

Para confirmar, sete um breakpoint em `push ecx` enquanto cria infantaria, mude `0x2C` para `0x41` e *infantry* para *worker* ‚Äî o jogo cria um trabalhador mesmo clicando em infantaria. Funcionou!

Como a estrutura completa √© complexa, vamos simplesmente **copiar a estrutura** quando um trabalhador √© criado e reutiliz√°-la.

# Localizando o Loop Principal do Jogo

Precisamos de um lugar para chamar a fun√ß√£o de recrutamento periodicamente. O loop principal do jogo √© perfeito. Para encontr√°-lo, siga a cadeia de chamadas de recrutamento para cima ‚Äî eventualmente voc√™ chegarar√° num `call` que, ao tentar *Execute till return*, faz o jogo continuar executando indefinidamente (porque voc√™ est√° dentro de um loop sem `ret`). Sete um breakpoint neste `call` ‚Äî ele vai disparar continuamente. Esse √© o loop principal!

# Localizando o Dinheiro do Jogador

Wyrmsun usa DMA para o dinheiro. Usaremos o **pointer scan do Cheat Engine** (em vez de reverter manualmente):

1. Encontre o endere√ßo do dinheiro
2. Clique com bot√£o direito ‚Üí *Pointer scan*
3. Reinicie o jogo e encontre o novo endere√ßo do dinheiro
4. Em *Pointer Scan* ‚Üí *Rescan Memory* com o novo endere√ßo
5. Repita v√°rias vezes at√© obter poucos ponteiros consistentes

Resultado exemplo:
```c++
wyrmsun.exe + 0x0061A504
[+0x78] ‚Üí [+0x04] ‚Üí [+0x08] ‚Üí [+0x04] ‚Üí [+0] ‚Üí [+0x14]
```

# C√≥digo Din√¢mico

Wyrmsun carrega c√≥digo em endere√ßos que mudam (ASLR). Para lidar com isso, calculamos todos os endere√ßos como **offsets do endere√ßo base do m√≥dulo**:

```c++
wyrmsun_base = GetModuleHandle(L"wyrmsun.exe");
// endere√ßo real = wyrmsun_base + offset_fixo
```

Voc√™ pode descobrir o base address e os offsets pela aba *Symbols* no x64dbg.

# Criando a DLL

A DLL ter√° **duas code caves**:

1. **Cave de recrutamento** ‚Äî copia a estrutura do trabalhador quando uma unidade √© criada
2. **Cave do loop** ‚Äî verifica o dinheiro e chama a fun√ß√£o de recrutamento quando > 3000

**Cave de recrutamento ‚Äî extraindo a estrutura:**

```c++
DWORD* base;
DWORD* unitbase;
unsigned char unitdata[0x110];
bool init = false;

__declspec(naked) void recruit_unit_codecave() {
    __asm {
        pushad
        mov base, ecx   // salva o ponteiro do ecx
    }

    unitbase = (DWORD*)(*base);
    memcpy(unitdata, unitbase, 0x110);   // copia toda a estrutura
    init = true;

    __asm {
        popad
        push ecx
        mov ecx, esi
        call recruit_unit_call_address
        jmp recruit_unit_ret_address
    }
}
```

**Cave do loop ‚Äî chamando o recrutamento automaticamente:**

```c++
if (init && *gold > 3000) {
    memcpy(unitbase, unitdata, 0x110);   // restaura a estrutura do trabalhador
    __asm {
        mov ecx, base
        push ecx
        call recruit_unit_call_address
    }
}
```

Compile, injete e inicie um jogo. Recrute uma unidade para capturar a estrutura, depois acumule dinheiro. Trabalhadores come√ßar√£o a ser recrutados automaticamente! ü§ñ

O c√≥digo completo est√° no [GitHub](https://github.com/GameHackingAcademy/Wyrmsun_Macrobot).

&nbsp;
